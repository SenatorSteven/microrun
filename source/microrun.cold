
/*! microrun.cold

MIT License

Copyright (C) 2020 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#define _POSIX_C_SOURCE /*-*/ (200112L)
	#define _DEFAULT_SOURCE

	#include <dirent.h>
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include "headers/cold/cold.hold"
	#include "headers/microrun.hold"
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microrun"

	#define ROOT_UID /*--------------------------------------*/ (0)
	#define ROOT_GID /*--------------------------------------*/ (0)

	#define PTHREAD_CREATE_SUCCESS /*------------------------*/ (0)
	#define PTHREAD_SETCANCELSTATE_SUCCESS /*----------------*/ (0)
	#define PTHREAD_SETCANCELTYPE_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_MUTEXATTR_INIT_SUCCESS /*----------------*/ (0)
	#define PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS /*----------*/ (0)
	#define PTHREAD_MUTEXATTR_DESTROY_SUCCESS /*-------------*/ (0)
	#define PTHREAD_MUTEX_INIT_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_MUTEX_LOCK_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_MUTEX_TRYLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_MUTEX_UNLOCK_SUCCESS /*------------------*/ (0)
	#define PTHREAD_MUTEX_DESTROY_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_CONDATTR_INIT_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_CONDATTR_SETPSHARED_SUCCESS /*-----------*/ (0)
	#define PTHREAD_CONDATTR_DESTROY_SUCCESS /*--------------*/ (0)
	#define PTHREAD_COND_INIT_SUCCESS /*---------------------*/ (0)
	#define PTHREAD_COND_WAIT_SUCCESS /*---------------------*/ (0)
	#define PTHREAD_COND_TIMEDWAIT_SUCCESS /*----------------*/ (0)
	#define PTHREAD_COND_SIGNAL_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_COND_BROADCAST_SUCCESS /*----------------*/ (0)
	#define PTHREAD_COND_DESTROY_SUCCESS /*------------------*/ (0)
	#define PTHREAD_RWLOCKATTR_INIT_SUCCESS /*---------------*/ (0)
	#define PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS /*---------*/ (0)
	#define PTHREAD_RWLOCKATTR_DESTROY_SUCCESS /*------------*/ (0)
	#define PTHREAD_RWLOCK_INIT_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_RWLOCK_WRLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_RDLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_UNLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_DESTROY_SUCCESS /*----------------*/ (0)
	#define PTHREAD_CANCEL_SUCCESS /*------------------------*/ (0)
	#define PTHREAD_JOIN_SUCCESS /*--------------------------*/ (0)

	#define GETHOSTNAME_SUCCESS /*---------------------------*/ (0)

	#define DEFAULT_OUTPUT_STREAM /*-------------------------*/ (stdout)
	#define DEFAULT_ERROR_STREAM /*--------------------------*/ (stderr)

	#define MESSAGE_START /*---------------------------------*/ ("\x1b[1m")
	#define MESSAGE_FATAL /*---------------------------------*/ ("\x1b[91m")
	#define MESSAGE_ERROR /*---------------------------------*/ ("\x1b[33m")
	#define MESSAGE_EVENT /*---------------------------------*/ ("\x1b[32m")
	#define MESSAGE_END /*-----------------------------------*/ ("\x1b[m")

	#define NONE_ARGUMENT /*---------------------------------*/ (0)
	#define UNRECOGNIZED_ARGUMENT /*-------------------------*/ (1)
	#define HELP_ARGUMENT /*---------------------------------*/ (2)
	#define STDOUT_ARGUMENT /*-------------------------------*/ (3)
	#define STDERR_ARGUMENT /*-------------------------------*/ (4)
	#define CONFIG_ARGUMENT /*-------------------------------*/ (5)
	#define ERROR_ARGUMENT /*--------------------------------*/ (6)
	#define SERVER_ARGUMENT /*-------------------------------*/ (7)

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define NONE_NORMAL_HINT /*------------------------------*/ (b(0000000000))
	#define USER_POSITION_NORMAL_HINT /*---------------------*/ (b(0000000001))
	#define USER_SIZE_NORMAL_HINT /*-------------------------*/ (b(0000000010))
	#define PROGRAM_POSITION_NORMAL_HINT /*------------------*/ (b(0000000100))
	#define PROGRAM_SIZE_NORMAL_HINT /*----------------------*/ (b(0000001000))
	#define PROGRAM_MINIMUM_SIZE_NORMAL_HINT /*--------------*/ (b(0000010000))
	#define PROGRAM_MAXIMUM_SIZE_NORMAL_HINT /*--------------*/ (b(0000100000))
	#define PROGRAM_RESIZE_INCREMENT_NORMAL_HINT /*----------*/ (b(0001000000))
	#define PROGRAM_ASPECT_NORMAL_HINT /*--------------------*/ (b(0010000000))
	#define PROGRAM_BASE_SIZE_NORMAL_HINT /*-----------------*/ (b(0100000000))
	#define PROGRAM_WINDOW_GRAVITY_NORMAL_HINT /*------------*/ (b(1000000000))

	#define NONE_HINT /*-------------------------------------*/ (b(000000000))
	#define INPUT_HINT /*------------------------------------*/ (b(000000001))
	#define STATE_HINT /*------------------------------------*/ (b(000000010))
	#define ICON_PIXMAP_HINT /*------------------------------*/ (b(000000100))
	#define ICON_WINDOW_HINT /*------------------------------*/ (b(000001000))
	#define ICON_POSITION_HINT /*----------------------------*/ (b(000010000))
	#define ICON_MASK_HINT /*--------------------------------*/ (b(000100000))
	#define WINDOW_GROUP_HINT /*-----------------------------*/ (b(001000000))
	#define URGENCY_HINT /*----------------------------------*/ (b(100000000))

	#define WITHDRAWN_STATE /*-------------------------------*/ (0)
	#define NORMAL_STATE /*----------------------------------*/ (1)
	#define ICON_STATE /*------------------------------------*/ (3)

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none) k(NONE##p) \
		, n(NULL) k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)    k(NONE##p) \
		, v(execute) k(EXECUTE##p) \
		, v(restart) k(RESTART##p) \
		, v(exit)    k(EXIT##p) \
		, n(NULL)    k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define NONE_GRAB_DEVICE /*------------------------------*/ (0)
	#define KEYBOARD_GRAB_DEVICE /*--------------------------*/ (1)
	#define POINTER_GRAB_DEVICE /*---------------------------*/ (2)

	#define QUIT() /*----------------------------------------*/ local void               quit(int signal)
	#define REAPSPAWNEDPROCESSES() /*------------------------*/ local void               reapSpawnedProcesses(const int signal)

	#define INITMEMORYSYSTEM() /*----------------------------*/ local bool               initMemorySystem(void)
	#define PUSHPOINTER() /*---------------------------------*/ local uint32            _pushPointer(const char *const file, const int line, void *const pointer, const char *const label, int (*const freeFunction)(void *))
	#define POPPOINTER() /*----------------------------------*/ local bool               popPointer(const uint32 token)
	#define UPDATEPOINTER() /*-------------------------------*/ local bool               updatePointer(const uint32 token, void *const pointer)
	#define IFREE() /*---------------------------------------*/ local int                iFree(void *const pointer)
	#define IXCBDISCONNECT() /*------------------------------*/ local int                iXCBDisconnect(void *const pointer)
	#define ISHMCTL() /*-------------------------------------*/ local int                ishmctl(void *const pointer)
	#define FINIMEMORYSYSTEM() /*----------------------------*/ local bool               finiMemorySystem(void)

	#define INITPERMISSIONSYSTEM() /*------------------------*/ local bool               initPermissionSystem(PermissionSystem *const permissionSystem)
	#define SETPERMISSIONS() /*------------------------------*/ local bool               setPermissions(PermissionSystem *const permissionSystem)
	#define LOWERPERMISSIONS() /*----------------------------*/ local bool               lowerPermissions(PermissionSystem *const permissionSystem)
	#define RAISEPERMISSIONS() /*----------------------------*/ local bool               raisePermissions(PermissionSystem *const permissionSystem)
	#define DROPPERMISSIONS() /*-----------------------------*/ local bool               dropPermissions(PermissionSystem *const permissionSystem)
	#define FINIPERMISSIONSYSTEM() /*------------------------*/ local bool               finiPermissionSystem(PermissionSystem *const permissionSystem)

	#define IDENTIFYARGUMENT() /*----------------------------*/ local uint8              identifyArgument(const char *p)
	#define INSENSITIVESTRINGCOMPARE() /*--------------------*/ local bool               insensitiveStringCompare(const char *s0, const char *s1)
	#define SENSITIVESTRINGCOMPARE() /*----------------------*/ local bool               sensitiveStringCompare(const char *s0, const char *s1)

	#define RANDRQUERYVERSIONUNCHECKED() /*------------------*/ local xcb_void_cookie_t  randrQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)

	#define INITMONITORSYSTEM() /*---------------------------*/ local bool               initMonitorSystem(MonitorSystem *const monitorSystem)
	#define CREATEMONITORS() /*------------------------------*/ local bool               createMonitors(MonitorSystem *const monitorSystem)
	#define GETWHICHMONITOR() /*-----------------------------*/ local Monitor *          getWhichMonitor(MonitorSystem *const monitorSystem, const uint8 whichMonitor)
	#define DESTROYMONITORS() /*-----------------------------*/ local bool               destroyMonitors(MonitorSystem *const monitorSystem)
	#define FINDPOINTERMONITOR() /*--------------------------*/ local Monitor *          findPointerMonitor(MonitorSystem *const monitorSystem)
	#define FINDRECTANGLEMONITOR() /*------------------------*/ local Monitor *          findRectangleMonitor(MonitorSystem *const monitorSystem, const int x, const int y, const int width, const int height)
	#define FINDWINDOWMONITOR() /*---------------------------*/ local Monitor *          findWindowMonitor(MonitorSystem *const monitorSystem, const xcb_window_t window)
	#define FINIMONITORSYSTEM() /*---------------------------*/ local bool               finiMonitorSystem(MonitorSystem *const monitorSystem)

	#define SETELEMENTPREFERENCES() /*-----------------------*/ local bool               setElementPreferences(ElementPreferences *const elementPreferences)

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool               initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool               createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool               createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool               mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool               configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool               drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool               setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool               drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool               unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool               destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool               getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool               findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool               finiWindowSystem(WindowSystem *const windowSystem)

	#define INITSLEEPTHREADSYSTEM() /*-----------------------*/ local bool               initSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)
	#define SETSLEEPTHREADOPERATION() /*---------------------*/ local bool               setSleepThreadOperation(SleepThreadSystem *const sleepThreadSystem, bool (*const risingOperation)(void *const arg), void *const risingOperationArgument, bool (*const fallingOperation)(void *const arg), void *const fallingOperationArgument, const bool loopOperation, const bool restartTimer)
	#define SETSLEEPTHREADSLEEPTIME() /*---------------------*/ local bool               setSleepThreadSleepTime(SleepThreadSystem *const sleepThreadSystem, const uint milliseconds)
	#define BOOTSLEEPTHREAD() /*-----------------------------*/ local bool               bootSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define SIGNALSLEEPTHREAD() /*---------------------------*/ local bool               signalSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define SLEEPTHREADMAIN() /*-----------------------------*/ local void *             sleepThreadMain(void *const arg)
	#define QUITSLEEPTHREAD() /*-----------------------------*/ local bool               quitSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define FINISLEEPTHREADSYSTEM() /*-----------------------*/ local bool               finiSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)

	#define INITSTRINGTREESYSTEM() /*------------------------*/ local bool               initStringTreeSystem(StringTreeSystem *const stringTreeSystem)
	#define BULKINSERTSTRING() /*----------------------------*/ local bool               bulkInsertString(StringTreeSystem *const stringTreeSystem, const char *const *const stringArray)
	#define INSERTSTRING() /*--------------------------------*/ local bool               insertString(StringTreeSystem *const stringTreeSystem, const char *string)
	#define GETSTRINGTREENODE() /*---------------------------*/ local StringTreeNode *   getStringTreeNode(StringTreeSystem *const stringTreeSystem, const char **const stringReturn)
	#define FINDSTRINGTREESTRING() /*------------------------*/ local bool               findStringTreeString(StringTreeSystem *const stringTreeSystem, char *const *const string)
	#define FINISTRINGTREESYSTEM() /*------------------------*/ local bool               finiStringTreeSystem(StringTreeSystem *const stringTreeSystem)

	#define INITSTDINSYSTEM() /*-----------------------------*/ local bool               initSTDINSystem(STDINSystem *const stdinSystem)
	#define CONNECTSTDIN() /*--------------------------------*/ local bool               connectSTDIN(STDINSystem *const stdinSystem)
	#define STDINMAIN() /*-----------------------------------*/ local void *             stdinMain(void *const arg)
	#define GETNEXTSTDINCHARACTER() /*-----------------------*/ local int                getNextSTDINCharacter(void *const arg)
	#define GETPREVIOUSSTDINCHARACTER() /*-------------------*/ local int                getPreviousSTDINCharacter(void *const arg)
	#define DISCONNECTSTDIN() /*-----------------------------*/ local bool               disconnectSTDIN(STDINSystem *const stdinSystem)
	#define FINISTDINSYSTEM() /*-----------------------------*/ local bool               finiSTDINSystem(STDINSystem *const stdinSystem)

	#define INITSHAREDMEMORYSYSTEM() /*----------------------*/ local bool               initSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)
	#define CONNECTSHAREDMEMORY() /*-------------------------*/ local bool               connectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define SHAREDMEMORYMAIN() /*----------------------------*/ local void *             sharedMemoryMain(void *const arg)
	#define GETNEXTSHAREDMEMORYCHARACTER() /*----------------*/ local int                getNextSharedMemoryCharacter(void *const arg)
	#define GETPREVIOUSSHAREDMEMORYCHARACTER() /*------------*/ local int                getPreviousSharedMemoryCharacter(void *const arg)
	#define DISCONNECTSHAREDMEMORY() /*----------------------*/ local bool               disconnectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define FINISHAREDMEMORYSYSTEM() /*----------------------*/ local bool               finiSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)

	#define INITSHORTCUTSYSTEM() /*--------------------------*/ local bool               initShortcutSystem(ShortcutSystem *const shortcutSystem)
	#define INSERTSHORTCUT() /*------------------------------*/ local bool               insertShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier, const uint8 onState, const Command command, char *const string, const uint32 stringToken, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define GETNEXTSHORTCUT() /*-----------------------------*/ local bool               getNextShortcut(ShortcutSystem *const shortcutSystem, const bool isRelease, uint8 code, uint16 modifier, int *const nextOffset)
	#define REMOVESHORTCUT() /*------------------------------*/ local bool               removeShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier)
	#define FINISHORTCUTSYSTEM() /*--------------------------*/ local bool               finiShortcutSystem(ShortcutSystem *const shortcutSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define UNGRABSHORTCUTS() /*-----------------------------*/ local bool               ungrabShortcuts(void)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define SETMEMORY() /*-----------------------------------*/ local void               setMemory(void *const destinationStart, const uint64 value, const uint itemAmount, const uint8 perByteAmount)
	#define COPYMEMORY() /*----------------------------------*/ local void               copyMemory(const void *const sourceStart, void *const destinationStart, uint byteAmount)
	#define SHIFTMEMORY() /*---------------------------------*/ local void               shiftMemory(void *const start, int byteAmount, int byteOffset)
	#define COMPAREMEMORY() /*-------------------------------*/ local bool               compareMemory(const void *memory0, const void *memory1, const uint byteAmount)
	#define FINDSTRINGLENGTH() /*----------------------------*/ local uint               findStringLength(const void *string)
	#define FINDSUBSTRING() /*-------------------------------*/ local char *             findSubstring(const char *const string, const uint stringLength, const char *const substring, const uint substringLength)
	#define UTF8TOUCS2() /*----------------------------------*/ local uint               UTF8ToUCS2(uint8 *const utf8Start, const uint utf8Length, uint16 *const ucs2Start, const uint ucs2Length)
	#define INTERSECTS() /*----------------------------------*/ local bool               intersects(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1)
	#define GETINTERSECTION() /*-----------------------------*/ local void               getIntersection(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1, int *const xReturn, int *const yReturn, int *const widthReturn, int *const heightReturn)
	#define LOADFILE() /*------------------------------------*/ local bool               loadFile(const char *const path, LoadedFile *const loadedFileReturn)
	#define SPAWNPROCESS() /*--------------------------------*/ local void               spawnProcess(const void *const string)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool               xcb_sync(void)
	#define GETTIMESTAMP() /*--------------------------------*/ local xcb_timestamp_t    getTimestamp(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8              getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)
	#define GRABDEVICE() /*----------------------------------*/ local bool               grabDevice(const uint8 device, const uint attemptAmount)
	#define UNGRABDEVICE() /*--------------------------------*/ local bool               ungrabDevice(const uint8 device)
	#define FILLDRAWABLE() /*--------------------------------*/ local void               fillDrawable(const xcb_drawable_t drawable, const xcb_gcontext_t gc, const int16 x, const int16 y, const uint16 width, const uint16 height, const uint32 color)
	#define SETCLIPPINGRECTANGLE() /*------------------------*/ local bool               setClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const uint width, const uint height)
	#define TIGHTENCLIPPINGRECTANGLE() /*--------------------*/ local bool               tightenClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const int width, const int height, int *const clipXReturn, int *const clipYReturn, int *const clipWidthReturn, int *const clipHeightReturn)
	#define UNSETCLIPPINGRECTANGLE() /*----------------------*/ local bool               unsetClippingRectangle(const xcb_gcontext_t gc)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#define OPENERRORSTREAM() /*-----------------------------*/ local bool               openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------------------*/ local bool               closeErrorStream(void)

	#define xcb_wait_for_reply(a, b, c) /*-------------------*/ (xcb_wait_for_reply(a, (b).sequence, c))
	#define xcb_discard_reply(a, b) /*-----------------------*/ (xcb_discard_reply(a, (b).sequence))
	#define xcb_send_event(a, b, c, d, e) /*-----------------*/ (xcb_send_event(a, b, c, d, (void *)(e)))
	#define xcb_send_event_checked(a, b, c, d, e) /*---------*/ (xcb_send_event_checked(a, b, c, d, (void *)(e)))

	#define EMPTY(void) /*-----------------------------------*/ EMPTY_MACRO
	#define SELF(self) /*------------------------------------*/ self
	#define STRINGIFY(identifier) /*-------------------------*/ #identifier
	#define ENUM_CONTENT(content) /*-------------------------*/ content##_CONTENT(SELF, EMPTY, EMPTY, _##content) content##_ENUM
	#define STRING_CONTENT(content) /*-----------------------*/ content##_CONTENT(EMPTY, STRINGIFY, SELF, _##content)

	#define ASCII_TO_UCS2(c) /*------------------------------*/ ((c) << 8)

	#define pushPointer(a, b, c) /*--------------------------*/ (_pushPointer(__FILE__, __LINE__, a, b, (int (*const)(void *))(c)))

	#if DEBUG
		#define useEventBase(n0, n1) /*-*/ n0 == n1##EventName? n1##BaseEvent
		#define useEventName(n0, n1) /*-*/ n0 == n1##EventName? "X " #n1 " event"
		#define printXEvent(n) /*-------*/ { \
			uint base = ((*event).response_type & ~b(10000000)) - ( \
			      n == baseEventName? 0 \
				: useEventBase(n, randr) \
				: ((*event).response_type & ~b(10000000)) - countof(baseEventName) + 1 \
			); \
			fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s%s:%s %s\n", colorStart, programName, colorEvent \
				, n == baseEventName? "X event" \
				: useEventName(n, randr) \
				: "X unrecognized extension event" \
				, colorEnd \
				, n != baseEventName and n != randrEventName? "unhandled extension event" \
				: *(n + (base >= countof(n)? countof(n) - 1 : base)) \
			); \
		}
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printXEvent(n) /*-------*/ EMPTY_MACRO
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/

/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def uint8 /*-*/ Command;
	def uint8 /*-*/ Instruction;
	def uint8 /*-*/ JmpPoint;

	def struct{
		const char * /*--------*/ label;
		uint64 * /*------------*/ data;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ line;
		const char * /*--------*/ file;
		int /*-----------------*/ (*free)(void *);
	} Pointer;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		Pointer * /*-----------*/ data;
		uint8 /*---------------*/ pad0[7];
		bool /*----------------*/ mutexCreated;
		pthread_mutex_t /*-----*/ mutex;
	} MemoryManagerSystem;

	def struct{
		uid_t /*---------------*/ normalUID;
		gid_t /*---------------*/ normalGID;
	} PermissionSystem;

	def struct{
		xcb_atom_t /*----------*/ MICRO_INIT;
		xcb_atom_t /*----------*/ MANAGER;
		xcb_atom_t /*----------*/ WM_NAME;
		xcb_atom_t /*----------*/ WM_ICON_NAME;
		xcb_atom_t /*----------*/ WM_NORMAL_HINTS;
		xcb_atom_t /*----------*/ WM_SIZE_HINTS;
		xcb_atom_t /*----------*/ WM_HINTS;
		xcb_atom_t /*----------*/ WM_CLASS;
		xcb_atom_t /*----------*/ WM_TRANSIENT_FOR;
		xcb_atom_t /*----------*/ WM_PROTOCOLS;
		xcb_atom_t /*----------*/ WM_TAKE_FOCUS;
		xcb_atom_t /*----------*/ WM_DELETE_WINDOW;
		xcb_atom_t /*----------*/ WM_COLORMAP_WINDOWS;
		xcb_atom_t /*----------*/ WM_COLORMAP_NOTIFY;
		xcb_atom_t /*----------*/ WM_CLIENT_MACHINE;
		xcb_atom_t /*----------*/ WM_LOCALE_NAME;
		xcb_atom_t /*----------*/ WM_WINDOW_ROLE;
		xcb_atom_t /*----------*/ WM_COMMAND;
		xcb_atom_t /*----------*/ WM_CLIENT_LEADER;
		xcb_atom_t /*----------*/ WM_STATE;
		xcb_atom_t /*----------*/ WM_CHANGE_STATE;
		xcb_atom_t /*----------*/ WM_ICON_SIZE;
		xcb_atom_t /*----------*/ SM_CLIENT_ID;
		xcb_atom_t /*----------*/ UTF8_STRING;
		xcb_atom_t /*----------*/ _NET_SUPPORTED;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST_STACKING;
		xcb_atom_t /*----------*/ _NET_NUMBER_OF_DESKTOPS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_DESKTOP_VIEWPORT;
		xcb_atom_t /*----------*/ _NET_CURRENT_DESKTOP;
		xcb_atom_t /*----------*/ _NET_DESKTOP_NAMES;
		xcb_atom_t /*----------*/ _NET_ACTIVE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WORKAREA;
		xcb_atom_t /*----------*/ _NET_SUPPORTING_WM_CHECK;
		xcb_atom_t /*----------*/ _NET_VIRTUAL_ROOTS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_LAYOUT;
		xcb_atom_t /*----------*/ _NET_SHOWING_DESKTOP;
		xcb_atom_t /*----------*/ _NET_CLOSE_WINDOW;
		xcb_atom_t /*----------*/ _NET_MOVERESIZE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WM_MOVERESIZE;
		xcb_atom_t /*----------*/ _NET_RESTACK_WINDOW;
		xcb_atom_t /*----------*/ _NET_REQUEST_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_NAME;
		xcb_atom_t /*----------*/ _NET_WM_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DOCK;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_TOOLBAR;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_MENU;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_UTILITY;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_SPLASH;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DIALOG;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_NORMAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MODAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE_STICKY;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_VERT;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SHADED;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_TASKBAR;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_PAGER;
		xcb_atom_t /*----------*/ _NET_WM_STATE_HIDDEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_ABOVE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_BELOW;
		xcb_atom_t /*----------*/ _NET_WM_STATE_DEMANDS_ATTENTION;
		xcb_atom_t /*----------*/ _NET_WM_ALLOWED_ACTIONS;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MOVE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_RESIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MINIMIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_SHADE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_STICK;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_VERT;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CHANGE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CLOSE;
		xcb_atom_t /*----------*/ _NET_WM_STRUT;
		xcb_atom_t /*----------*/ _NET_WM_STRUT_PARTIAL;
		xcb_atom_t /*----------*/ _NET_WM_ICON_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_WM_ICON;
		xcb_atom_t /*----------*/ _NET_WM_PID;
		xcb_atom_t /*----------*/ _NET_WM_HANDLED_ICONS;
		xcb_atom_t /*----------*/ _NET_WM_USER_TIME;
		xcb_atom_t /*----------*/ _NET_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_PING;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST_COUNTER;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_ORIENTATION;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_OPCODE;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_MESSAGE_DATA;
		xcb_atom_t /*----------*/ _XEMBED_INFO;
		xcb_atom_t /*----------*/ _XEMBED;
		xcb_atom_t /*----------*/ _XROOTPMAP_ID;
	} CommonAtoms;

	def struct{
		xcb_atom_t /*----------*/ name;
		int32 /*---------------*/ leftX;
		int32 /*---------------*/ rightX;
		int32 /*---------------*/ topY;
		int32 /*---------------*/ bottomY;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		uint32 /*--------------*/ millimeterWidth;
		uint32 /*--------------*/ millimeterHeight;
	} Monitor;

	def struct{
		Monitor * /*-----------*/ start;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ size;
	} MonitorSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		int32 /*---------------*/ padding;
		int32 /*---------------*/ margin;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ paddingType;
		uint8 /*---------------*/ marginType;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ clipChildren;
		uint8 /*---------------*/ cornerUsed;
		uint32 /*--------------*/ cornerRadius;
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ bufferPixmap;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*--------*/ circlePixmap;
		uint32 /*--------------*/ windowInfoSize;
		WindowInfo * /*--------*/ windowInfoStart;
		uint32 /*--------------*/ windowInfoToken;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-----------*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ horizontalPadding;
		uint32 /*--------------*/ verticalPadding;
		uint32 /*--------------*/ horizontalMargin;
		uint32 /*--------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;

	def struct{
		bool /*----------------*/ inUse;
		Command /*-------------*/ command;
		uint16 /*--------------*/ modifier;
		int32 /*---------------*/ nextOffset;
		char * /*--------------*/ string;
		uint32 /*--------------*/ stringToken;
		int32 /*---------------*/ field0;
		int32 /*---------------*/ field1;
		int32 /*---------------*/ field2;
		int32 /*---------------*/ field3;
		int32 /*---------------*/ field4;
		uint8 /*---------------*/ onState;
		bool /*----------------*/ hasBeenPressed;
		uint8 /*---------------*/ pad0[6];
	} ModifierNode;

	def struct{
		ModifierNode * /*------*/ modifierStart;
		uint32 /*--------------*/ modifierToken;
		uint32 /*--------------*/ modifierSize;
		uint32 /*--------------*/ modifierAllocated;
		uint32 /*--------------*/ modifierNotInUseOffset;
		uint32 /*--------------*/ codeListStart[SHORTCUT_CODE_AMOUNT];
		uint32 /*--------------*/ codeListWall[SHORTCUT_CODE_AMOUNT];
	} ShortcutSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		void * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} Image;

	def struct{
		char * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} LoadedFile;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagerSystem /*------------*/ memoryManagerSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local ElementPreferences /*-------------*/ windowPreferences;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ baseEventName[] = {"error", "unrecognized", "key press", "key release", "button press", "button release", "motion notify", "enter notify", "leave notify", "focus in", "focus out", "keymap notify", "expose", "graphics expose", "no expose", "visibility notify", "create notify", "destroy notify", "unmap notify", "map notify", "map request", "reparent notify", "configure notify", "configure request", "gravity notify", "resize request", "circulate notify", "circulate request", "property notify", "selection clear", "selection request", "selection notify", "colormap notify", "client message", "mapping notify", "generic event", "unrecognized"};
	local const char *const /*--------------*/ baseErrorName[] = {"unrecognized", "request", "value", "window", "pixmap", "atom", "cursor", "font", "match", "drawable", "access", "allocation", "colormap", "graphics context", "id choice", "name", "length", "implementation", "unrecognized"};
	local const char *const /*--------------*/ baseOperationName[] = {"unrecognized", "create window", "change window attributes", "get window attributes", "destroy window", "destroy subwindows", "change save set", "reparent window", "map window", "map subwindows", "unmap window", "unmap subwindows", "configure window", "circulate window", "get geometry", "query tree", "intern atom", "get atom name", "change property", "delete property", "get property", "list properties", "set selection owner", "get selection owner", "convert selection", "send event", "grab pointer", "ungrab pointer", "grab button", "ungrab button", "change active pointer grab", "grab keyboard", "ungrab keyboard", "grab key", "ungrab key", "allow events", "grab server", "ungrab server", "query pointer", "get motion events", "translate coordinates", "warp pointer", "set input focus", "get input focus", "query keymap", "open font", "close font", "query font", "query text extents", "list fonts", "list fonts with info", "set font path", "get font path", "create pixmap", "free pixmap", "create graphics context", "change graphics context", "copy graphics context", "set dashes", "set clip rectangles", "free graphics context", "clear area", "copy area", "copy plane", "poly point", "poly line", "poly segment", "poly rectangle", "poly arc", "fill poly", "poly fill rectangle", "poly fill arc", "put image", "get image", "poly text (8)", "poly text (16)", "image text (8)", "image text (16)", "create colormap", "free colormap", "copy colormap and free", "install colormap", "uninstall colormap", "list installed colormaps", "allocate color", "allocate named color", "allocate color cells", "allocate color planes", "free colors", "store colors", "store named color", "query colors", "lookup color", "create cursor", "create glyph cursor", "free cursor", "recolor cursor", "query best size", "query extension", "list extensions", "change keyboard mapping", "get keyboard mapping", "change keyboard control", "get keyboard control", "bell", "change pointer control", "get pointer control", "set screen saver", "get screen saver", "change hosts", "list hosts", "set access control", "set close down mode", "kill client", "rotate properties", "force screen saver", "set pointer mapping", "get pointer mapping", "set modifier mapping", "get modifier mapping", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "no", "unrecognized"};
	local const char *const /*--------------*/ randrEventName[] = {"screen change notify", "notify", "unrecognized"};
	local const char *const /*--------------*/ randrErrorName[] = {"bad output", "bad crtc", "bad mode", "bad provider", "unrecognized"};
	local const char *const /*--------------*/ randrOperationName[] = {"query version", "unrecognized", "set screen config", "unrecognized", "select input", "get screen info", "get screen size range", "set screen size", "get screen resources", "get output info", "list output properties", "query output property", "configure output property", "change output property", "delete output property", "get output property", "create mode", "destroy mode", "add output mode", "delete output mode", "get crtc info", "set crtc config", "get crtc gamma size", "get crtc gamma", "set crtc gamma", "get screen resources current", "set crtc transform", "get crtc transform", "get panning", "set panning", "set output primary", "get output primary", "get providers", "get provider info", "set provider offload sink", "set provider output source", "list provider properties", "query provider property", "configure provider property", "change provider property", "delete provider property", "get provider property", "get monitors", "set monitor", "delete monitor", "create lease", "free lease", "unrecognized"};

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
	#define getScope1Scope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(stop) \
	}
	local const Instruction *const /*-------*/ globalScopeInstruction[] = getGlobalScope(Instruction);
	local const Instruction *const /*-------*/ scope1ScopeInstruction[] = getScope1Scope(Instruction);

	local StringTreeSystem *const *const /*-*/ globalScopeInstructionData[] = getGlobalScope(InstructionData);
	local StringTreeSystem *const *const /*-*/ scope1ScopeInstructionData[] = getScope1Scope(InstructionData);
	#undef  getScope1Scope
	#undef  getGlobalScope
	#undef  getInstructionData
	#undef  getInstruction
/*!}*/

/*!functions:{*/
	QUIT();
	REAPSPAWNEDPROCESSES();
	INITMEMORYSYSTEM();
	PUSHPOINTER();
	POPPOINTER();
	UPDATEPOINTER();
	IFREE();
	IXCBDISCONNECT();
	ISHMCTL();
	FINIMEMORYSYSTEM();
	INITPERMISSIONSYSTEM();
	SETPERMISSIONS();
	LOWERPERMISSIONS();
	RAISEPERMISSIONS();
	DROPPERMISSIONS();
	FINIPERMISSIONSYSTEM();
	IDENTIFYARGUMENT();
	INSENSITIVESTRINGCOMPARE();
	SENSITIVESTRINGCOMPARE();
	RANDRQUERYVERSIONUNCHECKED();
	INITMONITORSYSTEM();
	CREATEMONITORS();
	GETWHICHMONITOR();
	DESTROYMONITORS();
	FINDPOINTERMONITOR();
	FINDRECTANGLEMONITOR();
	FINDWINDOWMONITOR();
	FINIMONITORSYSTEM();
	SETELEMENTPREFERENCES();
	INITWINDOWSYSTEM();
	CREATEWINDOWCIRCLEPIXMAP();
	CREATEWINDOWS();
	MAPWINDOWS();
	CONFIGUREWINDOWS();
	DRAWWINDOWS();
	SETWINDOWPROPERTIES();
	DRAWWINDOW();
	UNMAPWINDOWS();
	DESTROYWINDOWS();
	GETRECTANGLE();
	GETTYPEDNUMBER();
	FINDWINDOW();
	FINIWINDOWSYSTEM();
	INITSLEEPTHREADSYSTEM();
	SETSLEEPTHREADOPERATION();
	SETSLEEPTHREADSLEEPTIME();
	BOOTSLEEPTHREAD();
	SIGNALSLEEPTHREAD();
	SLEEPTHREADMAIN();
	QUITSLEEPTHREAD();
	FINISLEEPTHREADSYSTEM();
	INITSTRINGTREESYSTEM();
	BULKINSERTSTRING();
	INSERTSTRING();
	GETSTRINGTREENODE();
	FINDSTRINGTREESTRING();
	FINISTRINGTREESYSTEM();
	INITSTDINSYSTEM();
	CONNECTSTDIN();
	STDINMAIN();
	GETNEXTSTDINCHARACTER();
	GETPREVIOUSSTDINCHARACTER();
	DISCONNECTSTDIN();
	FINISTDINSYSTEM();
	INITSHAREDMEMORYSYSTEM();
	CONNECTSHAREDMEMORY();
	SHAREDMEMORYMAIN();
	GETNEXTSHAREDMEMORYCHARACTER();
	GETPREVIOUSSHAREDMEMORYCHARACTER();
	DISCONNECTSHAREDMEMORY();
	FINISHAREDMEMORYSYSTEM();
	INITSHORTCUTSYSTEM();
	INSERTSHORTCUT();
	GETNEXTSHORTCUT();
	REMOVESHORTCUT();
	FINISHORTCUTSYSTEM();
	SETCONFIGVARIABLES();
	READCONFIG();
	IFGETC();
	MATCHNAMELIST();
	MATCHINTEGER();
	MATCHSTRING();
	MATCHIMAGE();
	MATCHCOMMAND();
	UNGRABSHORTCUTS();
	FREECONFIGVARIABLES();
	SETMEMORY();
	COPYMEMORY();
	SHIFTMEMORY();
	COMPAREMEMORY();
	FINDSTRINGLENGTH();
	FINDSUBSTRING();
	UTF8TOUCS2();
	INTERSECTS();
	GETINTERSECTION();
	LOADFILE();
	SPAWNPROCESS();
	CREATECIRCLE();
	COMPOSITEIMAGES();
	COMPOSITEIMAGESOVER();
	COMPOSITEIMAGESAND();
	TWOPASSBOXBLUR();
	ROTATEIMAGE();
	XCB_SYNC();
	GETTIMESTAMP();
	GETWINDOWCLASS();
	GETFOCUSEDWINDOW();
	GRABDEVICE();
	UNGRABDEVICE();
	FILLDRAWABLE();
	SETCLIPPINGRECTANGLE();
	TIGHTENCLIPPINGRECTANGLE();
	UNSETCLIPPINGRECTANGLE();
	RESTART();
	CLEANUP();
	CANCELTHREADS();
	PRINTUNACCOUNTEDFORPOINTERS();
	PRINTERROR();
	PRINTTITLEDERROR();
	PRINTTITLEDQUOTEDERROR();
	PRINTCONNECTIONERROR();
	PRINTTITLEDNAMEDERROR();
	PRINTXERROR();
	PRINTTITLEDVALUEDERROR();
	PRINTCONFIGERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
/*!}*/

int main(int argumentAmount, const char *const *argument){
	(void)windowPreferences;
	(void)whichMonitor;
	(void)baseEventName;
	(void)findRectangleMonitor;
	(void)setElementPreferences;
	(void)createWindowCirclePixmap;
	(void)createWindows;
	(void)mapWindows;
	(void)configureWindows;
	(void)drawWindows;
	(void)findWindow;
	(void)setSleepThreadOperation;
	(void)setSleepThreadSleepTime;
	(void)bootSleepThread;
	(void)signalSleepThread;
	(void)copyMemory;
	(void)shiftMemory;
	(void)compareMemory;
	(void)findSubstring;
	(void)UTF8ToUCS2;
	(void)intersects;
	(void)createCircle;
	(void)compositeImages;
	(void)compositeImagesOver;
	(void)compositeImagesAnd;
	(void)twoPassBoxBlur;
	(void)rotateImage;
	(void)xcb_sync;
	(void)getWindowClass;
	(void)grabDevice;
	(void)ungrabDevice;
	(void)setClippingRectangle;
	(void)tightenClippingRectangle;
	(void)unsetClippingRectangle;
	jmp setSignalHandler;
	setSignalHandler:{
		def struct sigaction /*-*/ Sigaction;
		Sigaction s;
		processingSignal = true;
		s.sa_handler = quit;
		s.sa_flags = 0;
		sigemptyset(&s.sa_mask);
		sigaction(SIGABRT, &s, NULL);
		sigaction(SIGBUS,  &s, NULL);
		sigaction(SIGFPE,  &s, NULL);
		sigaction(SIGILL,  &s, NULL);
		sigaction(SIGINT,  &s, NULL);
		sigaction(SIGQUIT, &s, NULL);
		sigaction(SIGSEGV, &s, NULL);
		sigaction(SIGTERM, &s, NULL);
		sigaction(SIGTRAP, &s, NULL);
		sigaction(SIGUSR1, &s, NULL);
		sigaction(SIGUSR2, &s, NULL);
		s.sa_handler = reapSpawnedProcesses;
		s.sa_flags = SA_NOCLDSTOP;
		sigaction(SIGCHLD, &s, NULL);
		jmp setGlobals;
	}
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		{
			pthread_rwlockattr_t attributes;
			if(pthread_rwlockattr_init(&attributes) != PTHREAD_RWLOCKATTR_INIT_SUCCESS){
				printTitledError("pthread error", "could not init global lock attributes");
			}
			if(pthread_rwlockattr_setkind_np(&attributes, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS){
				printTitledError("pthread error", "could not set global lock attributes lock kind");
			}
			globalsLockCreated = pthread_rwlock_init(&globalsLock, &attributes) == PTHREAD_RWLOCK_INIT_SUCCESS;
			if(!globalsLockCreated){
				printTitledError("pthread error", "could not init globals lock");
			}
			if(pthread_rwlockattr_destroy(&attributes) != PTHREAD_RWLOCKATTR_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy global lock attributes");
			}
		}
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	getProgramArguments:{
		if(argumentAmount == 1){
			printError("%s%s: %susage:%s %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", colorStart, programName, colorError, colorEnd, programName, programName);
			jmp mainEmergencyExit;
		}
		dec argumentAmount;
		jmp checkErrorRedirection;
	}
	checkErrorRedirection:{
		if(!isatty(fileno(DEFAULT_ERROR_STREAM))){
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
		}
		jmp matchArgumentsLoop;
	}
	matchArgumentsLoop:{
		switch(identifyArgument(*(inc argument))){
			to HELP_ARGUMENT: /*---*/ jmp helpArgument;
			to CONFIG_ARGUMENT: /*-*/ jmp configArgument;
			to ERROR_ARGUMENT: /*--*/ jmp errorArgument;
			to SERVER_ARGUMENT: /*-*/ jmp serverArgument;
			off: /*----------------*/ jmp notAnArgument;
		}
	}
	helpArgument:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", programName, programName, programName);
		jmp mainEmergencyExit;
	}
	configArgument:{
		if(configPath){
			printTitledError("argument error", "the config argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no config value specified");
			jmp mainEmergencyExit;
		}
		configPath = *(inc argument);
		switch(identifyArgument(configPath)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openConfigFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayConfigUsage;
			off: /*----------------------*/ jmp displayNoConfigValue;
		}
	}
	openConfigFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "config directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "config value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(configPath, "r");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			jmp matchArgumentLoopControl;
		}
		file = fopen(configPath, "w");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(configPath);
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not read or create config file");
		jmp mainEmergencyExit;
	}
	displayConfigUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --config \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n\tand it will contain the hardcoded default configuration\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoConfigValue:{
		printTitledError("argument error", "no config value specified");
		jmp mainEmergencyExit;
	}
	errorArgument:{
		if(errorPath){
			printTitledError("argument error", "the error argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no error value specified");
			jmp mainEmergencyExit;
		}
		errorPath = *(inc argument);
		switch(identifyArgument(errorPath)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openErrorFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayErrorUsage;
			to STDOUT_ARGUMENT: /*-------*/ jmp setErrorStreamStdout;
			to STDERR_ARGUMENT: /*-------*/ jmp setErrorStreamStderr;
			off: /*----------------------*/ jmp displayNoErrorValue;
		}
	}
	openErrorFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "error directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "error value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(errorPath, "r");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		file = fopen(errorPath, "w");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(errorPath);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not create error file");
		jmp mainEmergencyExit;
	}
	displayErrorUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --error \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n", programName, programName);
		jmp mainEmergencyExit;
	}
	setErrorStreamStdout:{
		errorStream = stdout;
		jmp matchArgumentLoopControl;
	}
	setErrorStreamStderr:{
		errorStream = stderr;
		jmp matchArgumentLoopControl;
	}
	displayNoErrorValue:{
		printTitledError("argument error", "no error value specified");
		jmp mainEmergencyExit;
	}
	serverArgument:{
		if(connectionName){
			printTitledError("argument error", "the server argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no server value specified");
			jmp mainEmergencyExit;
		}
		connectionName = *(inc argument);
		switch(identifyArgument(connectionName)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp matchArgumentLoopControl;
			to HELP_ARGUMENT: /*---------*/ jmp displayServerUsage;
			off: /*----------------------*/ jmp displayNoServerValue;
		}
	}
	displayServerUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --server \"name\"\n\tthe name of the server, if running, should be something like \":0\"\n\tit can be checked with the $DISPLAY variable on a running server (no tty)\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoServerValue:{
		printTitledError("argument error", "no server value specified");
		jmp mainEmergencyExit;
	}
	notAnArgument:{
		printTitledQuotedError("argument error", *argument, "is not recognized as program argument, check help? [-h]");
		jmp mainEmergencyExit;
	}
	matchArgumentLoopControl:{
		if(dec argumentAmount){
			jmp matchArgumentsLoop;
		}
		jmp argumentsFinalCheck;
	}
	argumentsFinalCheck:{
		if(!configPath){
			printTitledError("argument error", "no config argument specified");
			jmp mainEmergencyExit;
		}
		if(errorPath and sensitiveStringCompare(errorPath, configPath)){
			mustOpenErrorStream = false;
			printTitledError("argument error", "config and error files are the same");
			jmp mainEmergencyExit;
		}
		jmp establishServerConnection;
	}
	establishServerConnection:{
		screenNumber = 0;
		connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
		connectionToken = pushPointer(connection, "X connection", iXCBDisconnect);
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(screen){
			screenWidthInPixels = (*screen).width_in_pixels;
			screenHeightInPixels = (*screen).height_in_pixels;
			screenWidthInMillimeters = (*screen).width_in_millimeters;
			screenHeightInMillimeters = (*screen).height_in_millimeters;
		}else{
			screenWidthInPixels = 0;
			screenHeightInPixels = 0;
			screenWidthInMillimeters = 0;
			screenHeightInMillimeters = 0;
		}
		jmp checkExtensionAvailability;
	}
	checkExtensionAvailability:{
		#define STRING(f) /*--------*/ { \
			  f("RANDR") \
		}
		#define BASE_POINTER /*-----*/ { \
			  &randrMajorOpcode \
			, &randrBaseEvent \
			, &randrBaseError \
		}
		#define VERSION_FUNCTION /*-*/ { \
			  &randrQueryVersionUnchecked \
		}
		#define MAJOR_VERSION /*----*/ { \
			  XCB_RANDR_MAJOR_VERSION \
		}
		#define MINOR_VERSION /*----*/ { \
			  XCB_RANDR_MINOR_VERSION \
		}
		char *nameStart[] = STRING(SELF);
		uint lengthStart[] = STRING(lengthof);
		xcb_query_extension_cookie_t cookieStart[countof(nameStart)];
		uint8 *basePointerStart[countof(nameStart) * 3] = BASE_POINTER;
		xcb_void_cookie_t (*versionFunctionStart[countof(nameStart)])(xcb_connection_t *, uint32, uint32) = VERSION_FUNCTION;
		uint32 majorVersionStart[countof(nameStart)] = MAJOR_VERSION;
		uint32 minorVersionStart[countof(nameStart)] = MINOR_VERSION;
		xcb_void_cookie_t versionCookieStart[countof(nameStart)];
		char **nameCurrent = nameStart;
		uint *lengthCurrent = lengthStart;
		xcb_query_extension_cookie_t *cookieCurrent = cookieStart;
		uint8 **basePointerCurrent = basePointerStart;
		xcb_void_cookie_t (**versionFunctionCurrent)(xcb_connection_t *, uint32, uint32) = versionFunctionStart;
		uint32 *majorVersionCurrent = majorVersionStart;
		uint32 *minorVersionCurrent = minorVersionStart;
		xcb_void_cookie_t *versionCookieCurrent = versionCookieStart;
		xcb_query_extension_cookie_t *const cookieWall = cookieCurrent + countof(nameStart);
		xcb_void_cookie_t *const versionCookieWall = versionCookieCurrent + countof(nameStart);
		jmp queryExtensionRequestLoop;
		queryExtensionRequestLoop:{
			*cookieCurrent = xcb_query_extension_unchecked(connection, *lengthCurrent, *nameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				inc lengthCurrent;
				jmp queryExtensionRequestLoop;
			}
			cookieCurrent = cookieStart;
			nameCurrent = nameStart;
			lengthCurrent = lengthStart;
			jmp queryExtensionReplyLoop;
		}
		queryExtensionReplyLoop:{
			xcb_query_extension_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "query extension reply", iFree);
			(*versionCookieCurrent).sequence = 0;
			**(basePointerCurrent + 0) = 0;
			**(basePointerCurrent + 1) = 0;
			**(basePointerCurrent + 2) = 0;
			if(!reply){
				printTitledNamedError("reply error", "could not get reply for", *nameCurrent);
			}else{
				if(!(*reply).present){
					printTitledQuotedError("extension error", *nameCurrent, "extension is not available");
				}else{
					*versionCookieCurrent = (*versionFunctionCurrent)(connection, *majorVersionCurrent, *minorVersionCurrent);
					**(basePointerCurrent + 0) = (*reply).major_opcode;
					**(basePointerCurrent + 1) = (*reply).first_event;
					**(basePointerCurrent + 2) = (*reply).first_error;
				}
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				basePointerCurrent += 3;
				inc versionFunctionCurrent;
				inc majorVersionCurrent;
				inc minorVersionCurrent;
				inc versionCookieCurrent;
				jmp queryExtensionReplyLoop;
			}
			versionCookieCurrent = versionCookieStart;
			jmp queryExtensionVersionReplyLoop;
		}
		queryExtensionVersionReplyLoop:{
			if((*versionCookieCurrent).sequence){
				void *const reply = xcb_wait_for_reply(connection, *versionCookieCurrent, NULL);
				uint32 token = pushPointer(reply, "query extension version reply", iFree);
				free(reply);
				popPointer(token);
			}
			if(inc versionCookieCurrent < versionCookieWall){
				jmp queryExtensionVersionReplyLoop;
			}
			jmp setAtoms;
		}
		#undef  MINOR_VERSION
		#undef  MAJOR_VERSION
		#undef  VERSION_FUNCTION
		#undef  BASE_POINTER
		#undef  STRING
	}
	setAtoms:{
		#define STRING(f) /*-*/ { \
			  f("MICRO_INIT") \
			, f("MANAGER") \
			, f("WM_NAME") \
			, f("WM_ICON_NAME") \
			, f("WM_NORMAL_HINTS") \
			, f("WM_SIZE_HINTS") \
			, f("WM_HINTS") \
			, f("WM_CLASS") \
			, f("WM_TRANSIENT_FOR") \
			, f("WM_PROTOCOLS") \
			, f("WM_TAKE_FOCUS") \
			, f("WM_DELETE_WINDOW") \
			, f("WM_COLORMAP_WINDOWS") \
			, f("WM_COLORMAP_NOTIFY") \
			, f("WM_CLIENT_MACHINE") \
			, f("WM_LOCALE_NAME") \
			, f("WM_WINDOW_ROLE") \
			, f("WM_COMMAND") \
			, f("WM_CLIENT_LEADER") \
			, f("WM_STATE") \
			, f("WM_CHANGE_STATE") \
			, f("WM_ICON_SIZE") \
			, f("SM_CLIENT_ID") \
			, f("UTF8_STRING") \
			, f("_NET_SUPPORTED") \
			, f("_NET_CLIENT_LIST") \
			, f("_NET_CLIENT_LIST_STACKING") \
			, f("_NET_NUMBER_OF_DESKTOPS") \
			, f("_NET_DESKTOP_GEOMETRY") \
			, f("_NET_DESKTOP_VIEWPORT") \
			, f("_NET_CURRENT_DESKTOP") \
			, f("_NET_DESKTOP_NAMES") \
			, f("_NET_ACTIVE_WINDOW") \
			, f("_NET_WORKAREA") \
			, f("_NET_SUPPORTING_WM_CHECK") \
			, f("_NET_VIRTUAL_ROOTS") \
			, f("_NET_DESKTOP_LAYOUT") \
			, f("_NET_SHOWING_DESKTOP") \
			, f("_NET_CLOSE_WINDOW") \
			, f("_NET_MOVERESIZE_WINDOW") \
			, f("_NET_WM_MOVERESIZE") \
			, f("_NET_RESTACK_WINDOW") \
			, f("_NET_REQUEST_FRAME_EXTENTS") \
			, f("_NET_WM_NAME") \
			, f("_NET_WM_VISIBLE_NAME") \
			, f("_NET_WM_ICON_NAME") \
			, f("_NET_WM_VISIBLE_ICON_NAME") \
			, f("_NET_WM_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE") \
			, f("_NET_WM_WINDOW_TYPE_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE_DOCK") \
			, f("_NET_WM_WINDOW_TYPE_TOOLBAR") \
			, f("_NET_WM_WINDOW_TYPE_MENU") \
			, f("_NET_WM_WINDOW_TYPE_UTILITY") \
			, f("_NET_WM_WINDOW_TYPE_SPLASH") \
			, f("_NET_WM_WINDOW_TYPE_DIALOG") \
			, f("_NET_WM_WINDOW_TYPE_NORMAL") \
			, f("_NET_WM_STATE") \
			, f("_NET_WM_STATE_MODAL") \
			, f("_NET_WM_STATE_STICKY") \
			, f("_NET_WM_STATE_MAXIMIZED_HORZ") \
			, f("_NET_WM_STATE_MAXIMIZED_VERT") \
			, f("_NET_WM_STATE_SHADED") \
			, f("_NET_WM_STATE_SKIP_TASKBAR") \
			, f("_NET_WM_STATE_SKIP_PAGER") \
			, f("_NET_WM_STATE_HIDDEN") \
			, f("_NET_WM_STATE_FULLSCREEN") \
			, f("_NET_WM_STATE_ABOVE") \
			, f("_NET_WM_STATE_BELOW") \
			, f("_NET_WM_STATE_DEMANDS_ATTENTION") \
			, f("_NET_WM_ALLOWED_ACTIONS") \
			, f("_NET_WM_ACTION_MOVE") \
			, f("_NET_WM_ACTION_RESIZE") \
			, f("_NET_WM_ACTION_MINIMIZE") \
			, f("_NET_WM_ACTION_SHADE") \
			, f("_NET_WM_ACTION_STICK") \
			, f("_NET_WM_ACTION_MAXIMIZE_HORZ") \
			, f("_NET_WM_ACTION_MAXIMIZE_VERT") \
			, f("_NET_WM_ACTION_FULLSCREEN") \
			, f("_NET_WM_ACTION_CHANGE_DESKTOP") \
			, f("_NET_WM_ACTION_CLOSE") \
			, f("_NET_WM_STRUT") \
			, f("_NET_WM_STRUT_PARTIAL") \
			, f("_NET_WM_ICON_GEOMETRY") \
			, f("_NET_WM_ICON") \
			, f("_NET_WM_PID") \
			, f("_NET_WM_HANDLED_ICONS") \
			, f("_NET_WM_USER_TIME") \
			, f("_NET_FRAME_EXTENTS") \
			, f("_NET_WM_PING") \
			, f("_NET_WM_SYNC_REQUEST") \
			, f("_NET_WM_SYNC_REQUEST_COUNTER") \
			, f("_NET_SYSTEM_TRAY_ORIENTATION") \
			, f("_NET_SYSTEM_TRAY_OPCODE") \
			, f("_NET_SYSTEM_TRAY_MESSAGE_DATA") \
			, f("_XEMBED_INFO") \
			, f("_XEMBED") \
			, f("_XROOTPMAP_ID") \
		}
		const char *const atomNameStart[] = STRING(SELF);
		const uint atomNameSizeStart[] = STRING(lengthof);
		xcb_intern_atom_cookie_t cookieStart[countof(atomNameStart)];
		const char *const *atomNameCurrent = atomNameStart;
		const uint *atomNameSizeCurrent = atomNameSizeStart;
		xcb_intern_atom_cookie_t *cookieCurrent = cookieStart;
		xcb_intern_atom_cookie_t *const cookieWall = cookieStart + countof(cookieStart);
		xcb_atom_t *atomCurrent = (void *)&atom;
		jmp atomRequestLoop;
		atomRequestLoop:{
			*cookieCurrent = xcb_intern_atom_unchecked(connection, false, *atomNameSizeCurrent, *atomNameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc atomNameSizeCurrent;
				inc atomNameCurrent;
				jmp atomRequestLoop;
			}
			cookieCurrent = cookieStart;
			jmp atomReplyLoop;
		}
		atomReplyLoop:{
			xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "atom reply", iFree);
			if(!reply){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "atom error", colorEnd, "could not get the", *(atomNameStart + (cookieCurrent - cookieStart)), "atom");
			}else{
				*atomCurrent = (*reply).atom;
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc atomCurrent;
				jmp atomReplyLoop;
			}
			jmp setOtherAtoms;
		}
		#undef  STRING
	}
	setOtherAtoms:{
		jmp selectInput;
	}
	selectInput:{
		xcb_void_cookie_t cookie;
		xcb_generic_error_t *error;
		uint32 token;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
		cookie = xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "select input event mask error", iFree);
		if(error){
			printTitledError("select input error", "could not apply to receive root window events");
			free(error);
			popPointer(token);
		}
		xcb_flush(connection);
		jmp setupScreenProfile;
	}
	setupScreenProfile:{
		xcb_depth_iterator_t depthIterator = xcb_screen_allowed_depths_iterator(screen);
		xcb_visualtype_iterator_t visualIterator;
		visual = (*screen).root_visual;
		depth = (*screen).root_depth;
		jmp findDepth;
		findDepth:{
			if((*depthIterator.data).depth == 32){
				visualIterator = xcb_depth_visuals_iterator(depthIterator.data);
				jmp findVisual;
			}
			if(!depthIterator.rem){
				printTitledError("screen error", "could not find a 32-bit depth visual, using default screen visual instead");
				jmp createColormap;
			}
			xcb_depth_next(&depthIterator);
			jmp findDepth;
		}
		findVisual:{
			if((*visualIterator.data)._class == XCB_VISUAL_CLASS_TRUE_COLOR){
				visual = (*visualIterator.data).visual_id;
				depth = (*depthIterator.data).depth;
				jmp createColormap;
			}
			if(!visualIterator.rem){
				printTitledError("screen error", "could not match 32-bit depth with a true color visual, using default screen visual instead");
				jmp createColormap;
			}
			dec visualIterator.rem;
			inc visualIterator.data;
			jmp findVisual;
		}
		createColormap:{
			colormap = xcb_generate_id(connection);
			xcb_create_colormap(connection, XCB_COLORMAP_ALLOC_NONE, colormap, (*screen).root, visual);
			jmp initSystems;
		}
	}
	initSystems:{
		createMonitors(&monitorSystem);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	readConfig:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		displaySimpleConfigErrors = true;
		restart(false);
		readConfig(true, configPath, &ifgetc, NULL);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		jmp eventLoopCheckShortcuts;
	}
	eventLoopCheckShortcuts:{
		if(keyPressNextOffset) /*------*/ jmp keyPressEvent;
		if(keyReleaseNextOffset) /*----*/ jmp keyReleaseEvent;
		if(buttonPressNextOffset) /*---*/ jmp buttonPressEvent;
		if(buttonReleaseNextOffset) /*-*/ jmp buttonReleaseEvent;
		jmp eventLoop;
	}
	eventLoop:{
		xcb_flush(connection);
		free(event);
		popPointer(eventToken);
		event = NULL;
		eventToken = 0;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		jmp waitForEvent;
	}
	waitForEvent:{
		event = xcb_wait_for_event(connection);
		eventToken = pushPointer(event, "event pointer", iFree);
		if(event){
			if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals read lock");
			}
			jmp switchEvent;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp waitForEvent;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch((*event).response_type & ~b(10000000)){
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp unexpectedEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp unexpectedEvent;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp unexpectedEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp unexpectedEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp unexpectedEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp unexpectedEvent;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp unexpectedEvent;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp unexpectedEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp unexpectedEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		}
		#undef  XCB_ONE
	}
	errorEvent:{
		#define e /*----------------------*/ ((xcb_generic_error_t *)event)
		#define printExtensionError(n) /*-*/ if((*e).major_code == n##MajorOpcode){ printXError(n##ErrorName); jmp eventLoop; }
		printExtensionError(randr);
		printXError(baseErrorName);
		jmp eventLoop;
		#undef  printExtensionError
		#undef  e
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		if(getNextShortcut(&keycodeShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &keyPressNextOffset)){
			jmp matchCommandPress;
		}
		shortcutCode = 0;
		shortcutModifier = XCB_NONE;
		expectingSecondKeyRelease = false;
		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch(matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4)){
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		}
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*-*/ jmp switchRandrEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch(((*event).response_type & ~b(10000000)) - randrBaseEvent){
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				createMonitors(&monitorSystem);
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		}
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
QUIT(){
	const char *message;
	const Pointer *start;
	const Pointer *current;
	const Pointer *wall;
	jmp evaluateHandlerAvailability;
	evaluateHandlerAvailability:{
		if(quitting){
			switch(signal){
				to SIGABRT: /*-*/ brk;
				to SIGBUS: /*--*/ brk;
				to SIGFPE: /*--*/ brk;
				to SIGILL: /*--*/ brk;
				to SIGSEGV: /*-*/ brk;
				to SIGTRAP: /*-*/ brk;
				off: /*--------*/ ret;
			}
			printTitledNamedError("quitting error", "could not free", labelExamined);
			jmp exit;
		}
		if(processingSignal and signal != SIGINT){
			ret;
		}
		processingSignal = true;
		jmp findSignal;
	}
	findSignal: switch(signal){
		to SIGABRT: /*-*/ message = "aborted"; /*--------------*/ jmp exitWithError;
		to SIGBUS: /*--*/ message = "hardware faulted"; /*-----*/ jmp exitWithError;
		to SIGFPE: /*--*/ message = "programmer math'd up"; /*-*/ jmp exitWithError;
		to SIGILL: /*--*/ message = "executable corrupted"; /*-*/ jmp exitWithError;
		to SIGINT: /*--*/ message = "interrupted"; /*----------*/ jmp exitWithError;
		to SIGQUIT: /*-*/ message = "voluntarily quitted"; /*--*/ jmp exitWithError;
		to SIGSEGV: /*-*/ message = "segmentation faulted"; /*-*/ jmp exitWithError;
		to SIGTERM: /*-*/ message = "terminated"; /*-----------*/ jmp exitWithError;
		to SIGTRAP: /*-*/ message = "trapped"; /*--------------*/ jmp exitWithError;
		to SIGUSR1: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		to SIGUSR2: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		off: /*--------*/ message = "unhandled signal"; /*-----*/ jmp exitWithError;
	}
	handleUserSignal:{
		processingSignal = false;
		ret;
	}
	exitWithError:{
		quitting = true;
		finiSTDINSystem(&stdinSystem);
		finiSharedMemorySystem(&sharedMemorySystem);
		printTitledError("signal received", message);
		if(memoryManagerSystem.allocated <= 1){
			jmp exit;
		}
		start = memoryManagerSystem.data;
		current = start + 1;
		wall = start + memoryManagerSystem.allocated;
		switch(signal){
			to SIGABRT:
			to SIGBUS:
			to SIGFPE:
			to SIGILL:
			to SIGSEGV:
			to SIGTRAP:{
				printError("%s%s: %spointers at time of error:%s\n", colorStart, programName, colorError, colorEnd);
				if(memoryManagerSystem.allocated > 1){
					jmp printPointedVariables;
				}
				printError("none\n");
				jmp freePointedVariablesLoop;
			}
			off:{
				jmp freePointedVariablesLoop;
			}
		}
	}
	printPointedVariables:{
		printUnaccountedForPointers(current, wall);
		current = start + 1;
		jmp freePointedVariablesLoop;
	}
	freePointedVariablesLoop:{
		if((*current).data){
			labelExamined = (*current).label;
			(*current).free((*current).data);
		}
		if(inc current < wall){
			jmp freePointedVariablesLoop;
		}
		jmp exit;
	}
	exit:{
		finiMemorySystem();
		closeErrorStream();
		exit(EXIT_SUCCESS);
	}
}
REAPSPAWNEDPROCESSES(){
	#define ANY_CHILD /*-*/ (-1)
	(void)signal;
	jmp reapSpawnedProcessLoop;
	reapSpawnedProcessLoop:{
		if(waitpid(ANY_CHILD, NULL, WNOHANG) > 0){
			jmp reapSpawnedProcessLoop;
		}
		ret;
	}
	#undef  ANY_CHILD
}
INITMEMORYSYSTEM(){
	#define DYNAMIC_DATA_SEGMENT_BLOCK_SIZE /*-*/ (16)
	#define SHMGET_FAILURE /*------------------*/ (-1)
	memoryManagerSystem.size = 0;
	memoryManagerSystem.allocated = 0;
	memoryManagerSystem.data = NULL;
	memoryManagerSystem.mutexCreated = pthread_mutex_init(&memoryManagerSystem.mutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
	if(!memoryManagerSystem.mutexCreated){
		printTitledError("pthread error", "could not init memory system mutex");
	}
	ret true;
}
PUSHPOINTER(){
	uint32 token;
	if(!memoryManagerSystem.mutexCreated or !pointer){
		ret 0;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp pushPointer;
	pushPointer:{
		Pointer *data;
		if(memoryManagerSystem.allocated == memoryManagerSystem.size){
			void *temp;
			memoryManagerSystem.size += DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
			if(!(temp = realloc(memoryManagerSystem.data, memoryManagerSystem.size * sizeof(Pointer)))){
				memoryManagerSystem.size -= DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
				token = 0;
				jmp emergencyExit;
			}
			memoryManagerSystem.data = temp;
			if(!memoryManagerSystem.allocated){
				(*memoryManagerSystem.data).data = (void *)1;
				inc memoryManagerSystem.allocated;
			}
		}
		token = memoryManagerSystem.allocated;
		data = memoryManagerSystem.data + token;
		(*data).label = label;
		(*data).data = pointer;
		(*data).token = token;
		(*data).line = line;
		(*data).file = file;
		(*data).free = freeFunction;
		inc memoryManagerSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret token;
	}
}
UPDATEPOINTER(){
	if(!memoryManagerSystem.mutexCreated or !memoryManagerSystem.data or !token or !pointer){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp updatePointer;
	updatePointer:{
		(*(memoryManagerSystem.data + token)).data = pointer;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
POPPOINTER(){
	if(!memoryManagerSystem.mutexCreated or !memoryManagerSystem.data or !token){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp popPointer;
	popPointer:{
		(*(memoryManagerSystem.data + token)).data = NULL;
		jmp trimSegmentLoop;
	}
	trimSegmentLoop:{
		if(!(*(memoryManagerSystem.data + dec memoryManagerSystem.allocated)).data){
			jmp trimSegmentLoop;
		}
		inc memoryManagerSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
IFREE(){
	free(pointer);
	ret 0;
}
IXCBDISCONNECT(){
	xcb_flush(connection);
	xcb_disconnect(pointer);
	ret 0;
}
ISHMCTL(){
	const int shmID = (int64)pointer;
	if(shmID != SHMGET_FAILURE){
		shmctl(shmID, IPC_RMID, NULL);
	}
	ret 0;
}
FINIMEMORYSYSTEM(){
	if(memoryManagerSystem.mutexCreated){
		if(pthread_mutex_destroy(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy memory system mutex");
		}
		memoryManagerSystem.mutexCreated = false;
	}
	free(memoryManagerSystem.data);
	memoryManagerSystem.size = 0;
	memoryManagerSystem.allocated = 0;
	memoryManagerSystem.data = NULL;
	ret true;
	#undef  SHMGET_FAILURE
	#undef  DYNAMIC_DATA_SEGMENT_BLOCK_SIZE
}
INITPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
SETPERMISSIONS(){
	const char *dataCurrent;
	const char *dataWall;
	LoadedFile loadedFile;
	char uidStringStart[10];
	char *uidStringCurrent;
	uid_t uid;
	if(!permissionSystem or ((*permissionSystem).normalUID != ROOT_UID and (*permissionSystem).normalGID != ROOT_GID)){
		ret false;
	}
	jmp loadFile;
	loadFile:{
		if(!loadFile("/proc/self/loginuid", &loadedFile)){
			ret false;
		}
		dataCurrent = loadedFile.dataStart;
		dataWall = dataCurrent + loadedFile.dataSize;
		uidStringCurrent = uidStringStart;
		uid = 0;
		jmp calculateUIDLoop;
	}
	calculateUIDLoop:{
		if(dataCurrent < dataWall){
			uid = uid * 10 + *dataCurrent - 48;
			*uidStringCurrent = *dataCurrent;
			inc uidStringCurrent;
			inc dataCurrent;
			jmp calculateUIDLoop;
		}
		free(loadedFile.dataStart);
		popPointer(loadedFile.dataToken);
		jmp getIDs;
	}
	getIDs:{
		struct passwd *passwd = getpwuid(uid);
		if(!passwd){
			ret false;
		}
		(*permissionSystem).normalUID = (*passwd).pw_uid;
		(*permissionSystem).normalGID = (*passwd).pw_gid;
		ret true;
	}
}
LOWERPERMISSIONS(){
	if(!permissionSystem or (geteuid() == (*permissionSystem).normalUID and getegid() == (*permissionSystem).normalGID)){
		ret false;
	}
	setegid((*permissionSystem).normalGID);
	seteuid((*permissionSystem).normalUID);
	ret true;
}
RAISEPERMISSIONS(){
	if(!permissionSystem or (geteuid() == getuid() and getegid() == getgid())){
		ret false;
	}
	setegid(getgid());
	seteuid(getuid());
	ret true;
}
DROPPERMISSIONS(){
	struct passwd *pw;
	char buffer[sizeof("/var/mail/") + 256];
	if(!permissionSystem){
		ret false;
	}
	pw = getpwuid((*permissionSystem).normalUID);
	if(!pw){
		ret false;
	}
	snprintf(buffer, sizeof(buffer), "/var/mail/%s", (*pw).pw_name);
	raisePermissions(permissionSystem);
	initgroups((*pw).pw_name, (*pw).pw_gid);
	setgid((*pw).pw_gid);
	setuid((*pw).pw_uid);
	unsetenv("SUDO_ASKPASS");
	unsetenv("SUDO_COMMAND");
	unsetenv("SUDO_EDITOR");
	unsetenv("SUDO_GID");
	unsetenv("SUDO_HOME");
	unsetenv("SUDO_PROMPT");
	unsetenv("SUDO_PS1");
	unsetenv("SUDO_UID");
	unsetenv("SUDO_USER");
	setenv("MAIL", buffer, true);
	setenv("HOME", (*pw).pw_dir, true);
	setenv("PWD", (*pw).pw_dir, true);
	setenv("USER", (*pw).pw_name, true);
	setenv("LOGNAME", (*pw).pw_name, true);
	setenv("SHELL", (*pw).pw_shell, true);
	setenv("LANG", setlocale(LC_ALL, ""), true);
	ret true;
}
FINIPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
IDENTIFYARGUMENT(){
	if(*p != '-') jmp findValueArgument;
	inc p;
	if(*p != '-') jmp findShortArgument;
	inc p;
	jmp findLongArgument;
	findValueArgument:{
		if(insensitiveStringCompare("stdout", p)) /*-*/ ret STDOUT_ARGUMENT;
		if(insensitiveStringCompare("stderr", p)) /*-*/ ret STDERR_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findShortArgument:{
		if(insensitiveStringCompare("h", p)) /*------*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("c", p)) /*------*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("e", p)) /*------*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("s", p)) /*------*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findLongArgument:{
		if(insensitiveStringCompare("help", p)) /*---*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("config", p)) /*-*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("error", p)) /*--*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("server", p)) /*-*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
}
INSENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		char c1 = *s1;
		c1 |= 32 * (c1 >= 'A' and c1 <= 'Z');
		if(*s0 != c1) /*-*/ ret false;
		if(!c1) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		if(*s0 != *s1) /*-*/ ret false;
		if(!*s0) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
RANDRQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	cookie.sequence = xcb_randr_query_version_unchecked(connection, majorVersion, minorVersion).sequence;
	ret cookie;
}
INITMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
CREATEMONITORS(){
	xcb_randr_get_monitors_reply_t *reply;
	uint32 replyToken;
	uint size;
	Monitor *start;
	Monitor *current;
	Monitor *wall;
	uint32 token;
	xcb_randr_monitor_info_iterator_t iterator;
	if(!monitorSystem){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL);
	replyToken = pushPointer(reply, "monitor reply", iFree);
	size = 1;
	if(reply){
		size = (*reply).nMonitors;
	}
	start = malloc(size * sizeof(Monitor));
	token = pushPointer(start, "monitor pointer", iFree);
	if(!start){
		printTitledError("memory allocation error", "could not allocate memory for monitors");
		free(reply);
		popPointer(replyToken);
		ret false;
	}
	current = start;
	wall = current + size;
	if(!reply){
		(*current).name = XCB_NONE;
		(*current).leftX = 0;
		(*current).topY = 0;
		(*current).rightX = screenWidthInPixels;
		(*current).bottomY = screenHeightInPixels;
		(*current).width = screenWidthInPixels;
		(*current).height = screenHeightInPixels;
		(*current).millimeterWidth = screenWidthInMillimeters;
		(*current).millimeterHeight = screenHeightInMillimeters;
		ret true;
	}
	iterator = xcb_randr_get_monitors_monitors_iterator(reply);
	jmp createMonitorLoop;
	createMonitorLoop:{
		if(current < wall){
			const Monitor *monitorCurrent = start;
			const Monitor *const monitorWall = current;
			const xcb_randr_monitor_info_t *const data = iterator.data;
			jmp removeSameMonitorLoop;
			removeSameMonitorLoop:{
				if(monitorCurrent < monitorWall){
					if((*monitorCurrent).leftX == (*data).x and (*monitorCurrent).topY == (*data).y){
						xcb_randr_monitor_info_next(&iterator);
						dec size;
						jmp createMonitorLoop;
					}
					inc monitorCurrent;
					jmp removeSameMonitorLoop;
				}
				(*current).name = (*data).name;
				(*current).leftX = (*data).x;
				(*current).topY = (*data).y;
				(*current).rightX = (*data).x + (*data).width;
				(*current).bottomY = (*data).y + (*data).height;
				(*current).width = (*data).width;
				(*current).height = (*data).height;
				(*current).millimeterWidth = (*data).width_in_millimeters;
				(*current).millimeterHeight = (*data).height_in_millimeters;
				xcb_randr_monitor_info_next(&iterator);
				inc current;
				jmp createMonitorLoop;
			}
		}
		free(reply);
		popPointer(replyToken);
		jmp compareMonitors;
	}
	compareMonitors:{
		if(size == (*monitorSystem).size){
			Monitor *oldCurrent = (*monitorSystem).start;
			current = start;
			wall = current + size;
			jmp compareMonitorLoop;
			compareMonitorLoop:{
				if(current < wall){
					if((*current).name != (*oldCurrent).name or (*current).leftX != (*oldCurrent).leftX or (*current).rightX != (*oldCurrent).rightX or (*current).width != (*oldCurrent).width or (*current).height != (*oldCurrent).height or (*current).millimeterWidth != (*oldCurrent).millimeterWidth or (*current).millimeterHeight != (*oldCurrent).millimeterHeight){
						jmp replaceMonitors;
					}
					inc oldCurrent;
					inc current;
					jmp compareMonitorLoop;
				}
				free(start);
				popPointer(token);
				ret false;
			}
		}
		jmp replaceMonitors;
	}
	replaceMonitors:{
		destroyMonitors(monitorSystem);
		(*monitorSystem).size = size;
		(*monitorSystem).start = start;
		(*monitorSystem).token = token;
		jmp trimMemory;
	}
	trimMemory:{
		if((*monitorSystem).size){
			void *const temp = realloc((*monitorSystem).start, (*monitorSystem).size * sizeof(Monitor));
			updatePointer((*monitorSystem).token, temp);
			if(temp){
				(*monitorSystem).start = temp;
			}
		}
		ret true;
	}
}
GETWHICHMONITOR(){
	switch(whichMonitor){
		to POINTER_WHICH_MONITOR:{
			ret findPointerMonitor(monitorSystem);
		}
		to FOCUSED_WINDOW_WHICH_MONITOR:{
			const xcb_window_t window = getFocusedWindow();
			if(window and window != (*screen).root){
				ret findWindowMonitor(monitorSystem, window);
			}
			ret findPointerMonitor(monitorSystem);
		}
		to ALL_WHICH_MONITOR:{
			ret NULL;
		}
		off:{
			ret NULL;
		}
	}
}
DESTROYMONITORS(){
	if(!monitorSystem){
		ret false;
	}
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
FINDPOINTERMONITOR(){
	xcb_query_pointer_reply_t *reply;
	uint32 token;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
	token = pushPointer(reply, "findPoinerMonitors() query pointer reply", iFree);
	if(reply){
		const int x = (*reply).root_x;
		const int y = (*reply).root_y;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		free(reply);
		popPointer(token);
		jmp findPointerMonitorLoop;
		findPointerMonitorLoop:{
			if(x >= (*current).leftX and x < (*current).rightX and y >= (*current).topY and y < (*current).bottomY){
				ret current;
			}
			if(inc current < wall){
				jmp findPointerMonitorLoop;
			}
		}
	}
	ret NULL;
}
FINDRECTANGLEMONITOR(){
	Monitor *current;
	Monitor *wall;
	uint mostPixelAmount;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size or width < 1 or height < 1){
		ret NULL;
	}
	current = (*monitorSystem).start;
	wall = current + (*monitorSystem).size;
	mostPixelAmount = 0;
	monitor = NULL;
	jmp findRectangleMonitorLoop;
	findRectangleMonitorLoop:{
		if(current < wall){
			int intersectionWidth;
			int intersectionHeight;
			uint pixelAmount;
			getIntersection((*current).leftX, (*current).topY, (*current).width, (*current).height, x, y, width, height, NULL, NULL, &intersectionWidth, &intersectionHeight);
			pixelAmount = intersectionWidth * intersectionHeight;
			if(pixelAmount > mostPixelAmount){
				monitor = current;
				mostPixelAmount = pixelAmount;
			}
			inc current;
			jmp findRectangleMonitorLoop;
		}
		ret monitor;
	}
}
FINDWINDOWMONITOR(){
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_translate_coordinates_cookie_t translateCoordinatesCookie;
	xcb_get_geometry_reply_t *getGeometryReply;
	uint32 getGeometryToken;
	xcb_translate_coordinates_reply_t *translateCoordinatesReply;
	uint32 translateCoordinatesToken;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	geometryCookie = xcb_get_geometry(connection, window);
	translateCoordinatesCookie = xcb_translate_coordinates(connection, window, (*screen).root, 0, 0);
	getGeometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	getGeometryToken = pushPointer(getGeometryReply, "findWindowMonitor() get geometry reply", iFree);
	translateCoordinatesReply = xcb_wait_for_reply(connection, translateCoordinatesCookie, NULL);
	translateCoordinatesToken = pushPointer(translateCoordinatesReply, "findWindowMonitor() translate coordinates reply", iFree);
	monitor = NULL;
	if(getGeometryReply and translateCoordinatesReply){
		const int width = (*getGeometryReply).width + 2 * (*getGeometryReply).border_width;
		const int height = (*getGeometryReply).height + 2 * (*getGeometryReply).border_width;
		const int leftX = (*translateCoordinatesReply).dst_x;
		const int topY = (*translateCoordinatesReply).dst_y;
		const int rightX = leftX + width;
		const int bottomY = topY + height;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		int mostPixels = 0;
		jmp findWindowMonitorLoop;
		findWindowMonitorLoop:{
			if((*current).leftX < rightX and (*current).rightX > leftX and (*current).topY < bottomY and (*current).bottomY > topY){
				const int width = ((*current).  rightX <  rightX? (*current). rightX :  rightX) - ((*current).leftX > leftX? (*current).leftX : leftX);
				const int height = ((*current).bottomY < bottomY? (*current).bottomY : bottomY) - ((*current). topY >  topY? (*current). topY :  topY);
				const int pixels = width * height;
				if(pixels > mostPixels){
					mostPixels = pixels;
					monitor = current;
				}
			}
			if(inc current < wall){
				jmp findWindowMonitorLoop;
			}
		}
	}
	free(getGeometryReply);
	popPointer(getGeometryToken);
	free(translateCoordinatesReply);
	popPointer(translateCoordinatesToken);
	ret monitor;
}
FINIMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	destroyMonitors(monitorSystem);
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
SETELEMENTPREFERENCES(){
	if(!elementPreferences){
		ret false;
	}
	(*elementPreferences).x = 0;
	(*elementPreferences).y = 0;
	(*elementPreferences).xOffset = 0;
	(*elementPreferences).yOffset = 0;
	(*elementPreferences).width = 0;
	(*elementPreferences).height = 0;
	(*elementPreferences).padding = 0;
	(*elementPreferences).margin = 0;
	(*elementPreferences).xType = NONE_NUMBER_TYPE;
	(*elementPreferences).yType = NONE_NUMBER_TYPE;
	(*elementPreferences).xOffsetType = NONE_NUMBER_TYPE;
	(*elementPreferences).yOffsetType = NONE_NUMBER_TYPE;
	(*elementPreferences).widthType = NONE_NUMBER_TYPE;
	(*elementPreferences).heightType = NONE_NUMBER_TYPE;
	(*elementPreferences).paddingType = NONE_NUMBER_TYPE;
	(*elementPreferences).marginType = NONE_NUMBER_TYPE;
	(*elementPreferences).position = NONE_POSITION;
	(*elementPreferences).horizontalAlignment = NONE_HORIZONTAL_ALIGNMENT;
	(*elementPreferences).verticalAlignment = NONE_VERTICAL_ALIGNMENT;
	(*elementPreferences).clipChildren = false;
	(*elementPreferences).cornerUsed = NONE_CORNER;
	(*elementPreferences).cornerRadius = 0;
	(*elementPreferences).foreground = 0x00000000;
	(*elementPreferences).background = 0x00000000;
	(*elementPreferences).selectedForeground = 0x00000000;
	(*elementPreferences).selectedBackground = 0x00000000;
	ret true;
}
INITWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	(*windowSystem).circlePixmap = XCB_NONE;
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	ret true;
}
CREATEWINDOWCIRCLEPIXMAP(){
	Image image;
	xcb_gcontext_t gc;
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!windowSystem){
		ret false;
	}
	if(!radius){
		if((*windowSystem).circlePixmap){
			xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
			(*windowSystem).circlePixmap = XCB_NONE;
		}
		ret true;
	}
	if(!createCircle(radius, foreground, background, &image)){
		ret false;
	}
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	gc = xcb_generate_id(connection);
	valueList.generateExpose = false;
	(*windowSystem).circlePixmap = xcb_generate_id(connection);
	xcb_create_pixmap(connection, depth, (*windowSystem).circlePixmap, (*screen).root, image.width, image.height);
	xcb_create_gc(connection, gc, (*windowSystem).circlePixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*windowSystem).circlePixmap, gc, image.width, image.height, 0, 0, 0, depth, image.dataSize, image.dataStart);
	xcb_free_gc(connection, gc);
	free(image.dataStart);
	popPointer(image.dataToken);
	ret true;
}
CREATEWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	struct{
		uint32 /*---------*/ backgroundColor;
		uint32 /*---------*/ borderColor;
		uint32 /*---------*/ overrideRedirect;
		uint32 /*---------*/ eventMask;
		xcb_colormap_t /*-*/ colormap;
	} windowValueList;
	struct{
		uint32 /*---------*/ generateExpose;
	} gcValueList;
	if(!windowSystem or !amount){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = amount;
	(*windowSystem).windowInfoStart = malloc((*windowSystem).windowInfoSize * sizeof(WindowInfo));
	(*windowSystem).windowInfoToken = pushPointer((*windowSystem).windowInfoStart, "window info pointer", iFree);
	if(!(*windowSystem).windowInfoStart){
		printTitledError("memory allocation error", "could not allocate memory for windows");
		(*windowSystem).windowInfoSize = 0;
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	windowValueList.backgroundColor = 0x00000000;
	windowValueList.borderColor = 0x00000000;
	windowValueList.overrideRedirect = overrideRedirect;
	windowValueList.eventMask = eventMask;
	windowValueList.colormap = colormap;
	gcValueList.generateExpose = false;
	jmp createWindowLoop;
	createWindowLoop:{
		if(current < wall){
			(*current).window = xcb_generate_id(connection);
			(*current).bufferPixmap = xcb_generate_id(connection);
			(*current).pixmap = xcb_generate_id(connection);
			(*current).gc = xcb_generate_id(connection);
			(*current).x = 0;
			(*current).y = 0;
			(*current).width = 0;
			(*current).height = 0;
			(*current).mapped = false;
			xcb_create_window(connection, depth, (*current).window, (*screen).root, 0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP, &windowValueList);
			xcb_create_pixmap(connection, depth, (*current).bufferPixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_pixmap(connection, depth, (*current).pixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
			xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
			inc current;
			jmp createWindowLoop;
		}
		ret true;
	}
}
MAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	xcb_timestamp_t userTime;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
		uint32 /*-*/ stackMode;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or (*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	userTime = getTimestamp();
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			(*current).mapped = false;
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
				xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*current).window, atom._NET_WM_USER_TIME, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &userTime);
				(*current).mapped = true;
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
CONFIGUREWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
DRAWWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !monitorSystem or !windowPreferences){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp drawWindowLoop;
	drawWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				drawWindow(windowSystem, current, windowPreferences, findWindowMonitor(monitorSystem, (*current).window), NULL);
			}
			inc current;
			jmp drawWindowLoop;
		}
		ret true;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[1];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_NORMAL;
	*(state + 0) = XCB_NONE;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch((*windowPreferences).position){
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		}
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		jmp clearArea;
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
UNMAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp unmapWindowLoop;
	unmapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_unmap_window(connection, (*current).window);
				(*current).mapped = false;
			}
			inc current;
			jmp unmapWindowLoop;
		}
		(*windowSystem).mapped = false;
		ret true;
	}
}
DESTROYWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize){
		ret false;
	}
	unmapWindows(windowSystem);
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp destroyWindowLoop;
	destroyWindowLoop:{
		if(current < wall){
			xcb_free_gc(connection, (*current).gc);
			xcb_free_pixmap(connection, (*current).pixmap);
			xcb_free_pixmap(connection, (*current).bufferPixmap);
			xcb_destroy_window(connection, (*current).window);
			inc current;
			jmp destroyWindowLoop;
		}
		ret true;
	}
}
GETRECTANGLE(){
	Monitor *monitor;
	int x;
	int y;
	int xOffset;
	int yOffset;
	uint width;
	uint height;
	uint horizontalPadding;
	uint verticalPadding;
	uint horizontalMargin;
	uint verticalMargin;
	int parentX;
	int parentY;
	uint parentWidth;
	uint parentHeight;
	if(_monitor){
		monitor = _monitor;
		parentX = (*monitor).leftX;
		parentY = (*monitor).topY;
		parentWidth = (*monitor).width;
		parentHeight = (*monitor).height;
	}elif(parentRectangle){
		monitor = (*parentRectangle).monitor;
		parentX = 0;
		parentY = 0;
		parentWidth = (*parentRectangle).width;
		parentHeight = (*parentRectangle).height;
		if(!monitor){
			ret false;
		}
	}else{
		ret false;
	}
	x = getTypedNumber((*preferences).x, (*preferences).xType, HORIZONTAL_AXIS, parentWidth, monitor);
	y = getTypedNumber((*preferences).y, (*preferences).yType, VERTICAL_AXIS, parentHeight, monitor);
	xOffset = getTypedNumber((*preferences).xOffset, (*preferences).xOffsetType, HORIZONTAL_AXIS, parentWidth, monitor);
	yOffset = getTypedNumber((*preferences).yOffset, (*preferences).yOffsetType, VERTICAL_AXIS, parentHeight, monitor);
	width = getTypedNumber((*preferences).width, (*preferences).widthType, HORIZONTAL_AXIS, parentWidth, monitor);
	height = getTypedNumber((*preferences).height, (*preferences).heightType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, VERTICAL_AXIS, parentHeight, monitor);
	if((*preferences).position){
		if((*preferences).position < LEFT_POSITION){
			width = (*monitor).width;
		}
		if((*preferences).position >= LEFT_POSITION){
			height = (*monitor).height;
		}
	}
	if((*preferences).position == LEFT_POSITION){
		x = parentX + 0 * (parentWidth - width) / 2;
	}elif((*preferences).position == RIGHT_POSITION){
		x = parentX + 2 * (parentWidth - width) / 2;
	}elif((*preferences).horizontalAlignment){
		x = parentX + ((*preferences).horizontalAlignment - 1) * (parentWidth - width) / 2;
	}
	if((*preferences).position == TOP_POSITION){
		y = parentY + 0 * (parentHeight - height) / 2;
	}elif((*preferences).position == BOTTOM_POSITION){
		y = parentY + 2 * (parentHeight - height) / 2;
	}elif((*preferences).verticalAlignment){
		y = parentY + ((*preferences).verticalAlignment - 1) * (parentHeight - height) / 2;
	}
	(*rectangle).monitor = monitor;
	(*rectangle).x = x + xOffset;
	(*rectangle).y = y + yOffset;
	(*rectangle).width = width;
	(*rectangle).height = height;
	(*rectangle).horizontalPadding = horizontalPadding;
	(*rectangle).verticalPadding = verticalPadding;
	(*rectangle).horizontalMargin = horizontalMargin;
	(*rectangle).verticalMargin = verticalMargin;
	ret true;
}
GETTYPEDNUMBER(){
	switch(type){
		to INTEGER_NUMBER_TYPE: /*----*/ ret number;
		to PERCENTAGE_NUMBER_TYPE: /*-*/ ret size * number / 100;
		to MILLIMETER_NUMBER_TYPE: /*-*/ jmp matchMillimeterType;
		off: /*-----------------------*/ ret 0;
	}
	matchMillimeterType: switch(axis){
		to HORIZONTAL_AXIS: /*--------*/ ret (*monitor).width * number / (*monitor).millimeterWidth;
		to VERTICAL_AXIS: /*----------*/ ret (*monitor).height * number / (*monitor).millimeterHeight;
		off: /*-----------------------*/ ret 0;
	}
}
FINDWINDOW(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !window){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp findWindowLoop;
	findWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				ret true;
			}
			inc current;
			jmp findWindowLoop;
		}
		ret false;
	}
}
FINIWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	ret true;
}
INITSLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}
SETSLEEPTHREADOPERATION(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = risingOperation;
	(*sleepThreadSystem).risingOperationArgument = risingOperationArgument;
	(*sleepThreadSystem).fallingOperation = fallingOperation;
	(*sleepThreadSystem).fallingOperationArgument = fallingOperationArgument;
	(*sleepThreadSystem).loopOperation = loopOperation;
	(*sleepThreadSystem).restartTimer = restartTimer;
	ret true;
}
SETSLEEPTHREADSLEEPTIME(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).seconds = milliseconds / 1000;
	(*sleepThreadSystem).nanoseconds = (milliseconds - (*sleepThreadSystem).seconds * 1000) * 1000000;
	ret true;
}
BOOTSLEEPTHREAD(){
	if(!sleepThreadSystem or (*sleepThreadSystem).threadCreated or (!(*sleepThreadSystem).risingOperation and !(*sleepThreadSystem).fallingOperation)){
		ret false;
	}
	if(!(*sleepThreadSystem).mutexCreated){
		(*sleepThreadSystem).mutexCreated = pthread_mutex_init(&(*sleepThreadSystem).mutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sleepThreadSystem).mutexCreated){
			printTitledError("pthread error", "could not init sleep operation mutex");
			ret false;
		}
	}
	if(!(*sleepThreadSystem).condCreated){
		(*sleepThreadSystem).condCreated = pthread_cond_init(&(*sleepThreadSystem).cond, NULL) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sleepThreadSystem).condCreated){
			printTitledError("pthread error", "could not init sleep operation cond");
			ret false;
		}
	}
	(*sleepThreadSystem).threadCreated = pthread_create(&(*sleepThreadSystem).thread, NULL, &sleepThreadMain, sleepThreadSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*sleepThreadSystem).threadCreated){
		printTitledError("pthread error", "could not create sleep operation thread");
		ret false;
	}
	ret true;
}
SIGNALSLEEPTHREAD(){
	if(!sleepThreadSystem or !(*sleepThreadSystem).mutexCreated or !(*sleepThreadSystem).condCreated or !(*sleepThreadSystem).threadCreated or !(*sleepThreadSystem).running){
		ret false;
	}
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
		printTitledError("pthread error", "could not signal sleep operation thread");
	}
	if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not unlock sleep operation mutex");
	}
	ret true;
}
SLEEPTHREADMAIN(){
	SleepThreadSystem *const sleepThreadSystem = arg;
	struct timespec ts;
	int waitReturn;
	bool error;
	if(!sleepThreadSystem){
		ret NULL;
	}
	error = false;
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	(*sleepThreadSystem).running = true;
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait sleep operation mutex");
		}
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		jmp conductRisingOperation;
	}
	conductRisingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		clock_gettime(CLOCK_REALTIME, &ts);
		ts.tv_sec += (*sleepThreadSystem).seconds;
		ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
		if((*sleepThreadSystem).risingOperation){
			error = !(*(*sleepThreadSystem).risingOperation)((*sleepThreadSystem).risingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp waitUntilTimedOut;
	}
	waitUntilTimedOut:{
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		waitReturn = pthread_cond_timedwait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex, &ts);
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		if(waitReturn != ETIMEDOUT){
			if(waitReturn != PTHREAD_COND_TIMEDWAIT_SUCCESS){
				printTitledError("pthread error", "could not wait sleep operation mutex");
			}
			if((*sleepThreadSystem).restartTimer){
				if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals read lock");
				}
				clock_gettime(CLOCK_REALTIME, &ts);
				ts.tv_sec += (*sleepThreadSystem).seconds;
				ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
			}
			jmp waitUntilTimedOut;
		}
		jmp conductFallingOperation;
	}
	conductFallingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		if((*sleepThreadSystem).fallingOperation){
			error = !(*(*sleepThreadSystem).fallingOperation)((*sleepThreadSystem).fallingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp checkMode;
	}
	checkMode:{
		if((*sleepThreadSystem).loopOperation){
			jmp conductRisingOperation;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		(*sleepThreadSystem).threadCreated = false;
		(*sleepThreadSystem).running = false;
		if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock sleep operation mutex");
		}
		ret NULL;
	}
}
QUITSLEEPTHREAD(){
	if(!sleepThreadSystem or (!(*sleepThreadSystem).threadCreated and !(*sleepThreadSystem).condCreated and !(*sleepThreadSystem).mutexCreated)){
		ret false;
	}
	(*sleepThreadSystem).quittingThread = true;
	if((*sleepThreadSystem).threadCreated){
		if((*sleepThreadSystem).mutexCreated and (*sleepThreadSystem).condCreated){
			if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
				printTitledError("pthread error", "could not lock sleep operation mutex");
			}
			if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
				printTitledError("pthread error", "could not signal sleep operation thread");
			}
			if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock sleep operation mutex");
			}
		}
		if(pthread_join((*sleepThreadSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join sleep operation thread");
		}
		(*sleepThreadSystem).threadCreated = false;
	}
	if((*sleepThreadSystem).condCreated){
		if(pthread_cond_destroy(&(*sleepThreadSystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation cond");
		}
		(*sleepThreadSystem).condCreated = false;
	}
	if((*sleepThreadSystem).mutexCreated){
		if(pthread_mutex_destroy(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation mutex");
		}
		(*sleepThreadSystem).mutexCreated = false;
	}
	(*sleepThreadSystem).quittingThread = false;
	ret true;
}
FINISLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	quitSleepThread(sleepThreadSystem);
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}
INITSTRINGTREESYSTEM(){
	#define DATA_BLOCK_SIZE /*-*/ (256)
	if(!stringTreeSystem){
		ret false;
	}
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
}
BULKINSERTSTRING(){
	const char *const *stringCurrent;
	if(!stringTreeSystem or !stringArray){
		ret false;
	}
	(*stringTreeSystem).stringArray = stringArray;
	stringCurrent = stringArray;
	jmp insertStringLoop;
	insertStringLoop:{
		insertString(stringTreeSystem, *stringCurrent);
		if(*(inc stringCurrent)){
			jmp insertStringLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		if((*stringTreeSystem).dataAllocated){
			void *temp;
			(*stringTreeSystem).dataSize = (*stringTreeSystem).dataAllocated;
			temp = realloc((*stringTreeSystem).dataStart, (*stringTreeSystem).dataSize * sizeof(StringTreeNode));
			updatePointer((*stringTreeSystem).dataToken, temp);
			if(temp){
				(*stringTreeSystem).dataStart = temp;
			}
		}
		ret true;
	}
}
INSERTSTRING(){
	uint size;
	uint allocated;
	StringTreeNode *data;
	StringTreeNode *node;
	bool returnValue;
	if(!stringTreeSystem or !string){
		ret false;
	}
	size = (*stringTreeSystem).dataSize;
	allocated = (*stringTreeSystem).dataAllocated;
	data = (*stringTreeSystem).dataStart;
	jmp findString;
	findString:{
		node = getStringTreeNode(stringTreeSystem, &string);
		if(data and (!node or (*node).letter & b(10000000))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(StringTreeNode));
			if(!(*stringTreeSystem).dataToken){
				(*stringTreeSystem).dataToken = pushPointer(temp, "string tree pointer", iFree);
			}else{
				updatePointer((*stringTreeSystem).dataToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for string tree nodes");
				size -= DATA_BLOCK_SIZE;
				returnValue = false;
				jmp completeString;
			}
			data = temp;
			node = data + nodeOffset;
			if(!allocated){
				(*node).letter = '\0';
				(*node).childrenAmount = 0;
				inc allocated;
			}
		}
		if((*node).childrenAmount >= STRING_TREE_NODE_CHILDREN_AMOUNT){
			printTitledError("insert string error", "out of space for new children in string node");
			ret false;
		}
		*((*node).offset + (*node).childrenAmount) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).childrenAmount = 0;
		inc allocated;
		if(*string){
			(*node).letter = *string;
			inc string;
			jmp addLetterLoop;
		}
		returnValue = true;
		jmp completeString;
	}
	completeString:{
		if(node){
			(*node).letter = b(10000000) | (*stringTreeSystem).counter;
			inc (*stringTreeSystem).counter;
			(*stringTreeSystem).dataSize = size;
			(*stringTreeSystem).dataAllocated = allocated;
			(*stringTreeSystem).dataStart = data;
		}
		ret returnValue;
	}
}
GETSTRINGTREENODE(){
	const uint16 *offsetCurrent;
	const uint16 *offsetWall;
	const char *string;
	StringTreeNode *data;
	StringTreeNode *node;
	char c;
	if(!stringTreeSystem or !(*stringTreeSystem).dataStart or !stringReturn){
		ret NULL;
	}
	data = (*stringTreeSystem).dataStart;
	node = data;
	string = *stringReturn;
	jmp findLetterLoop;
	findLetterLoop:{
		offsetCurrent = (*node).offset;
		offsetWall = offsetCurrent + (*node).childrenAmount;
		c = *string;
		c += (c >= 'A' and c <= 'Z') * 32 - (c == '_') * 50;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(offsetCurrent < offsetWall){
			StringTreeNode *const child = data + *offsetCurrent;
			if((*child).letter == c and c){
				inc string;
				node = child;
				jmp findLetterLoop;
			}
			if((*child).letter & b(10000000) and !c){
				(*stringTreeSystem).returnedCounter = ((*child).letter & ~b(10000000)) - 1;
				*stringReturn = string;
				ret child;
			}
			inc offsetCurrent;
			jmp nextLetterLoop;
		}
		*stringReturn = string;
		ret node;
	}
}
FINDSTRINGTREESTRING(){
	StringTreeNode *const node = getStringTreeNode(stringTreeSystem, (void *)string);
	if(!node or !((*node).letter & b(10000000))){
		ret false;
	}
	ret true;
}
FINISTRINGTREESYSTEM(){
	if(!stringTreeSystem){
		ret false;
	}
	free((*stringTreeSystem).dataStart);
	popPointer((*stringTreeSystem).dataToken);
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
	#undef  DATA_BLOCK_SIZE
}
INITSTDINSYSTEM(){
	#define STDIN_BLOCK_SIZE /*-*/ (1024)
	if(!stdinSystem){
		ret false;
	}
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
}
CONNECTSTDIN(){
	if(!stdinSystem or (*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).threadCreated = pthread_create(&(*stdinSystem).thread, NULL, &stdinMain, stdinSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*stdinSystem).threadCreated){
		printTitledError("pthread error", "could not create stdin thread");
		ret false;
	}
	ret true;
}
STDINMAIN(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem){
		jmp emergencyExit;
	}
	jmp setupThread;
	setupThread:{
		int oldState;
		int oldType;
		if(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldState) != PTHREAD_SETCANCELSTATE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel state");
		}
		if(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldType) != PTHREAD_SETCANCELTYPE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel type");
		}
		jmp initializeBuffer;
	}
	initializeBuffer:{
		(*stdinSystem).size = STDIN_BLOCK_SIZE;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = malloc((*stdinSystem).size * sizeof(char));
		(*stdinSystem).current = (*stdinSystem).start;
		(*stdinSystem).token = pushPointer((*stdinSystem).start, "stdin data pointer", iFree);
		if(!(*stdinSystem).start){
			printTitledError("memory allocation error", "could not allocate memory for stdin data");
			jmp emergencyExit;
		}
		jmp checkSTDIN;
	}
	checkSTDIN:{
		struct pollfd fds;
		fds.fd = STDIN_FILENO;
		fds.events = POLLIN;
		if(poll(&fds, 1, 10) > 0){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	clearSTDINLoop:{
		if(fread((*stdinSystem).start, sizeof(char), (*stdinSystem).size, stdin) == (*stdinSystem).size){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	waitIndefinitely:{
		char c;
		if((*stdinSystem).quittingThread){
			jmp emergencyExit;
		}
		c = fgetc(stdin);
		if((*stdinSystem).allocated == (*stdinSystem).size){
			const uint offset = (*stdinSystem).current - (*stdinSystem).start;
			void *temp;
			(*stdinSystem).size += STDIN_BLOCK_SIZE;
			temp = realloc((*stdinSystem).start, (*stdinSystem).size * sizeof(char));
			updatePointer((*stdinSystem).token, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for stdin data");
				(*stdinSystem).size -= STDIN_BLOCK_SIZE;
				jmp emergencyExit;
			}
			(*stdinSystem).start = temp;
			(*stdinSystem).current = (*stdinSystem).start + offset;
		}
		*(*stdinSystem).current = c;
		if(c != '\n'){
			inc (*stdinSystem).current;
			inc (*stdinSystem).allocated;
			jmp waitIndefinitely;
		}
		*(*stdinSystem).current = EOF;
		(*stdinSystem).current = (*stdinSystem).start;
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		(*stdinSystem).operating = true;
		readConfig(false, "stdin", &getNextSTDINCharacter, &getPreviousSTDINCharacter);
		(*stdinSystem).operating = false;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		(*stdinSystem).allocated = 0;
		(*stdinSystem).current = (*stdinSystem).start;
		jmp waitIndefinitely;
	}
	emergencyExit:{
		free((*stdinSystem).start);
		popPointer((*stdinSystem).token);
		(*stdinSystem).size = 0;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = NULL;
		(*stdinSystem).current = NULL;
		(*stdinSystem).token = 0;
		(*stdinSystem).threadCreated = false;
		(*stdinSystem).quittingThread = false;
		ret NULL;
	}
}
GETNEXTSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(inc (*stdinSystem).current - 1);
}
GETPREVIOUSSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(dec (*stdinSystem).current);
}
DISCONNECTSTDIN(){
	if(!stdinSystem or !(*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).quittingThread = true;
	if((*stdinSystem).threadCreated){
		if((*stdinSystem).operating){
			ret true;
		}
		if(pthread_cancel((*stdinSystem).thread) != PTHREAD_CANCEL_SUCCESS){
			printTitledError("pthread error", "could not cancel stdin thread");
		}
		if(pthread_join((*stdinSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join stdin thread");
		}
		(*stdinSystem).threadCreated = false;
	}
	free((*stdinSystem).start);
	popPointer((*stdinSystem).token);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).quittingThread = false;
	ret true;
}
FINISTDINSYSTEM(){
	if(!stdinSystem){
		ret false;
	}
	disconnectSTDIN(stdinSystem);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
	#undef  STDIN_BLOCK_SIZE
}
INITSHAREDMEMORYSYSTEM(){
	#define STAT_FAILURE /*----*/ (-1)
	#define SHMGET_FAILURE /*--*/ (-1)
	#define SHMAT_FAILURE /*---*/ ((void *)-1)
	#define SHMCTL_FAILURE /*--*/ (-1)
	#define SHMDT_FAILURE /*---*/ (-1)
	#define STAT_PATH /*-------*/ ("/dev/shm/" PROGRAM_NAME)
	#define SHM_KEY /*---------*/ (((s.st_dev << 20) & 0xfff00000) | ((s.st_ino << 8) & 0x000fff00) | 0x00000045)
	#define SHARED_SIZE /*-----*/ (65536)
	#define SHM_HEADER_SIZE /*-*/ (sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + sizeof(uint8))
	#define SHM_FOOTER_SIZE /*-*/ (2)
	#define SHM_BODY_SIZE /*---*/ (SHM_SIZE - SHM_HEADER_SIZE - SHM_FOOTER_SIZE)
	#define SHM_NONE /*--------*/ (0)
	if(!sharedMemorySystem){
		ret false;
	}
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
}
CONNECTSHAREDMEMORY(){
	def struct stat Stat;
	FILE *file;
	Stat s;
	if(!sharedMemorySystem or (*sharedMemorySystem).shmID != SHMGET_FAILURE){
		ret false;
	}
	jmp createKeyFile;
	createKeyFile:{
		uint32 token;
		file = fopen(STAT_PATH, "w");
		token = pushPointer(file, "shm file", fclose);
		if(!file){
			file = fopen(STAT_PATH, "r");
			token = pushPointer(file, "shm file", fclose);
			if(!file){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "shared memory error", colorEnd, "could neither create nor read", STAT_PATH, "file");
				ret false;
			}
		}
		fclose(file);
		popPointer(token);
		jmp getKeyFileStat;
	}
	getKeyFileStat:{
		if(stat(STAT_PATH, &s) == STAT_FAILURE){
			printTitledError("shared memory error", "could not generate shared memory key");
			ret false;
		}
		jmp createSharedMemory;
	}
	createSharedMemory:{
		(*sharedMemorySystem).shmID = shmget(SHM_KEY, SHARED_SIZE, IPC_CREAT | 0600);
		(*sharedMemorySystem).shmToken = pushPointer((void *)(int64)(*sharedMemorySystem).shmID, "shm id", ishmctl);
		if((*sharedMemorySystem).shmID == SHMGET_FAILURE){
			printTitledError("shared memory error", "could not create shared memory segment");
			ret false;
		}
		jmp attachToSharedMemory;
	}
	attachToSharedMemory:{
		(*sharedMemorySystem).start = shmat((*sharedMemorySystem).shmID, NULL, SHM_NONE);
		if((*sharedMemorySystem).start == SHMAT_FAILURE){
			printTitledError("shared memory error", "could not attach to shared memory");
			(*sharedMemorySystem).start = NULL;
			ret false;
		}
		(*sharedMemorySystem).token = pushPointer((*sharedMemorySystem).start, "shared memory pointer", shmdt);
		(*sharedMemorySystem).mutex = (void *)(*sharedMemorySystem).start;
		(*sharedMemorySystem).cond = (void *)((*sharedMemorySystem).start + sizeof(pthread_mutex_t));
		*((*sharedMemorySystem).start + SHM_HEADER_SIZE - sizeof(uint8)) = EMPTY_SHARED_STATUS;
		jmp createThreadObjects;
	}
	createThreadObjects:{
		pthread_mutexattr_t mutexAttributes;
		pthread_condattr_t condAttributes;
		if(pthread_mutexattr_init(&mutexAttributes) != PTHREAD_MUTEXATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared mutex attributes");
		}
		if(pthread_mutexattr_setpshared(&mutexAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared mutex shared process attribute");
		}
		(*sharedMemorySystem).mutexCreated = pthread_mutex_init((*sharedMemorySystem).mutex, &mutexAttributes) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sharedMemorySystem).mutexCreated){
			printTitledError("pthread error", "could not init shared mutex");
		}
		if(pthread_mutexattr_destroy(&mutexAttributes) != PTHREAD_MUTEXATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared mutex attributes");
		}
		if(pthread_condattr_init(&condAttributes) != PTHREAD_CONDATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared cond attributes");
		}
		if(pthread_condattr_setpshared(&condAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_CONDATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared cond shared process attribute");
		}
		(*sharedMemorySystem).condCreated = pthread_cond_init((*sharedMemorySystem).cond, &condAttributes) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sharedMemorySystem).condCreated){
			printTitledError("pthread error", "could not init shared cond");
		}
		if(pthread_condattr_destroy(&condAttributes) != PTHREAD_CONDATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared cond attributes");
		}
		(*sharedMemorySystem).threadCreated = pthread_create(&(*sharedMemorySystem).thread, NULL, &sharedMemoryMain, sharedMemorySystem) == PTHREAD_CREATE_SUCCESS;
		if(!(*sharedMemorySystem).threadCreated){
			printTitledError("pthread error", "could not create shared memory thread");
			ret false;
		}
		ret true;
	}
}
SHAREDMEMORYMAIN(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	uint8 *current;
	if(!sharedMemorySystem){
		ret NULL;
	}
	if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock shared mutex");
	}
	current = (*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait((*sharedMemorySystem).cond, (*sharedMemorySystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait shared mutex");
		}
		if((*sharedMemorySystem).quittingThread){
			*current = FULL_SHARED_STATUS;
			jmp emergencyExit;
		}
		if(*current == FULL_SHARED_STATUS){
			*current = EMPTY_SHARED_STATUS;
			if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals write lock");
			}
			(*sharedMemorySystem).current = current + 1;
			(*sharedMemorySystem).operating = true;
			readConfig(false, "transmitter", &getNextSharedMemoryCharacter, &getPreviousSharedMemoryCharacter);
			(*sharedMemorySystem).operating = false;
			(*sharedMemorySystem).current = NULL;
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
			if(*current == FULL_SHARED_STATUS){
				(*sharedMemorySystem).quittingFromInside = true;
				jmp emergencyExit;
			}
			*current = EMPTY_SHARED_STATUS;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock shared mutex");
		}
		(*sharedMemorySystem).threadCreated = false;
		disconnectSharedMemory(sharedMemorySystem);
		ret NULL;
	}
}
GETNEXTSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(inc (*sharedMemorySystem).current - 1);
}
GETPREVIOUSSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(dec (*sharedMemorySystem).current);
}
DISCONNECTSHAREDMEMORY(){
	if(!sharedMemorySystem or (!(*sharedMemorySystem).threadCreated and !(*sharedMemorySystem).quittingFromInside)){
		ret false;
	}
	jmp destroyThreadObjects;
	destroyThreadObjects:{
		(*sharedMemorySystem).quittingThread = true;
		if((*sharedMemorySystem).threadCreated){
			if((*sharedMemorySystem).operating){
				*((*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t)) = FULL_SHARED_STATUS;
				(*sharedMemorySystem).quittingThread = false;
				ret true;
			}
			if((*sharedMemorySystem).mutexCreated and (*sharedMemorySystem).condCreated){
				if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
					printTitledError("pthread error", "could not lock shared mutex");
				}
				if(pthread_cond_signal((*sharedMemorySystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
					printTitledError("pthread error", "could not signal shared thread");
				}
				if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock shared mutex");
				}
			}
			if(pthread_join((*sharedMemorySystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
				printTitledError("pthread error", "could not join shared thread");
			}
			(*sharedMemorySystem).threadCreated = false;
		}
		if((*sharedMemorySystem).cond and (*sharedMemorySystem).condCreated){
			if(pthread_cond_destroy((*sharedMemorySystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared cond");
			}
			(*sharedMemorySystem).condCreated = false;
		}
		if((*sharedMemorySystem).mutex and (*sharedMemorySystem).mutexCreated){
			if(pthread_mutex_destroy((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared mutex");
			}
			(*sharedMemorySystem).mutexCreated = false;
		}
		jmp markForDeletion;
	}
	markForDeletion:{
		if((*sharedMemorySystem).shmID != SHMGET_FAILURE and shmctl((*sharedMemorySystem).shmID, IPC_RMID, NULL) == SHMCTL_FAILURE){
			printTitledError("shared memory error", "could not mark shared memory for deletion");
		}
		popPointer((*sharedMemorySystem).shmToken);
		(*sharedMemorySystem).shmID = SHMGET_FAILURE;
		(*sharedMemorySystem).shmToken = 0;
		jmp detach;
	}
	detach:{
		if((*sharedMemorySystem).start and shmdt((*sharedMemorySystem).start) == SHMDT_FAILURE){
			printTitledError("shared memory error", "could not detach from shared memory");
		}
		popPointer((*sharedMemorySystem).token);
		(*sharedMemorySystem).start = NULL;
		(*sharedMemorySystem).current = NULL;
		(*sharedMemorySystem).token = 0;
		(*sharedMemorySystem).quittingFromInside = false;
		(*sharedMemorySystem).quittingThread = false;
		ret true;
	}
}
FINISHAREDMEMORYSYSTEM(){
	if(!sharedMemorySystem){
		ret false;
	}
	disconnectSharedMemory(sharedMemorySystem);
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
	#undef  SHM_NONE
	#undef  SHM_BODY_SIZE
	#undef  SHM_FOOTER_SIZE
	#undef  SHM_HEADER_SIZE
	#undef  SHARED_SIZE
	#undef  SHM_KEY
	#undef  STAT_PATH
	#undef  SHMDT_FAILURE
	#undef  SHMCTL_FAILURE
	#undef  SHMAT_FAILURE
	#undef  SHMGET_FAILURE
	#undef  STAT_FAILURE
}
INITSHORTCUTSYSTEM(){
	#define MODIFIER_DATA_BLOCK_SIZE /*-*/ (32)
	if(!shortcutSystem){
		ret false;
	}
	(*shortcutSystem).modifierSize = 0;
	(*shortcutSystem).modifierAllocated = 0;
	(*shortcutSystem).modifierNotInUseOffset = 0;
	(*shortcutSystem).modifierStart = NULL;
	(*shortcutSystem).modifierToken = 0;
	setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
	ret true;
}
INSERTSHORTCUT(){
	ModifierNode *node;
	if(!shortcutSystem or !onState or onState > RELEASE_SHORTCUT_STATE){
		ret false;
	}
	if((*shortcutSystem).modifierAllocated == (*shortcutSystem).modifierSize){
		void *temp;
		(*shortcutSystem).modifierSize += MODIFIER_DATA_BLOCK_SIZE;
		temp = realloc((*shortcutSystem).modifierStart, (*shortcutSystem).modifierSize * sizeof(ModifierNode));
		if(!(*shortcutSystem).modifierToken){
			(*shortcutSystem).modifierToken = pushPointer((*shortcutSystem).modifierStart, "shortcut modifier list pointer", iFree);
		}else{
			updatePointer((*shortcutSystem).modifierToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for shortcuts");
			(*shortcutSystem).modifierSize -= MODIFIER_DATA_BLOCK_SIZE;
			ret false;
		}
		(*shortcutSystem).modifierStart = temp;
		if(!(*shortcutSystem).modifierAllocated){
			(*shortcutSystem).modifierAllocated = 1;
			(*shortcutSystem).modifierNotInUseOffset = 1;
		}
	}
	node = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierNotInUseOffset;
	(*node).inUse = true;
	(*node).command = command;
	(*node).modifier = modifier;
	(*node).nextOffset = 0;
	(*node).string = string;
	(*node).stringToken = stringToken;
	(*node).field0 = field0;
	(*node).field1 = field1;
	(*node).field2 = field2;
	(*node).field3 = field3;
	(*node).field4 = field4;
	(*node).onState = onState;
	(*node).hasBeenPressed = false;
	if(!*((*shortcutSystem).codeListStart + code)){
		*((*shortcutSystem).codeListStart + code) = (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const uint offset = *((*shortcutSystem).codeListWall + code);
		(*((*shortcutSystem).modifierStart + offset)).nextOffset = (*shortcutSystem).modifierNotInUseOffset - offset;
	}
	*((*shortcutSystem).codeListWall + code) = (*shortcutSystem).modifierNotInUseOffset;
	if((*shortcutSystem).modifierNotInUseOffset == (*shortcutSystem).modifierAllocated){
		inc (*shortcutSystem).modifierAllocated;
		inc (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const ModifierNode *current = node + 1;
		const ModifierNode *const wall = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierAllocated;
		jmp findNextAvailableModifierNodeSlotLoop;
		findNextAvailableModifierNodeSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableModifierNodeSlotLoop;
			}
			(*shortcutSystem).modifierNotInUseOffset = current - (*shortcutSystem).modifierStart;
		}
	}
	ret true;
}
GETNEXTSHORTCUT(){
	ModifierNode *current;
	int offset;
	if(!shortcutSystem or !nextOffset){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	if(!*nextOffset){
		offset = *((*shortcutSystem).codeListStart + code);
		jmp findShortcutModifierLoop;
	}
	code = shortcutCode;
	modifier = shortcutModifier;
	offset = *nextOffset;
	jmp findShortcutModifierLoop;
	findShortcutModifierLoop:{
		if(offset){
			current += offset;
			if((*current).modifier == modifier){
				if(isRelease and !(*current).hasBeenPressed){
					jmp findShortcutModifierLoopControl;
				}
				shortcutCode = code;
				shortcutModifier = modifier;
				eventModifierNode = current;
				(*current).hasBeenPressed = !isRelease;
				if((*current).nextOffset){
					*nextOffset = current - (*shortcutSystem).modifierStart + (*current).nextOffset;
					ret true;
				}
				*nextOffset = 0;
				ret true;
			}
			jmp findShortcutModifierLoopControl;
		}
		*nextOffset = 0;
		ret false;
	}
	findShortcutModifierLoopControl:{
		offset = (*current).nextOffset;
		jmp findShortcutModifierLoop;
	}
}
REMOVESHORTCUT(){
	ModifierNode *modifierStart;
	ModifierNode *node;
	bool hasRemovedShortcut;
	if(!shortcutSystem){
		ret false;
	}
	modifierStart = (*shortcutSystem).modifierStart;
	node = modifierStart + *((*shortcutSystem).codeListStart + code);
	hasRemovedShortcut = false;
	if(node > modifierStart){
		ModifierNode *previousNode = NULL;
		uint modifierAllocated = (*shortcutSystem).modifierAllocated;
		uint modifierNotInUseOffset = (*shortcutSystem).modifierNotInUseOffset;
		jmp removeModifierLoop;
		removeModifierLoop:{
			const int nextOffset = (*node).nextOffset;
			if(modifier == (*node).modifier){
				(*node).inUse = false;
				free((*node).string);
				popPointer((*node).stringToken);
				if(!previousNode){
					*((*shortcutSystem).codeListStart + code) = !!nextOffset * *((*shortcutSystem).codeListStart + code) + nextOffset;
				}else{
					(*previousNode).nextOffset = !!nextOffset * (*previousNode).nextOffset + nextOffset;
				}
				if(node == modifierStart + modifierAllocated - 1){
					if(dec modifierAllocated < modifierNotInUseOffset){
						dec modifierNotInUseOffset;
					}
				}elif(node - modifierStart < modifierNotInUseOffset){
					modifierNotInUseOffset = node - modifierStart;
				}
				hasRemovedShortcut = true;
			}
			if(nextOffset){
				previousNode = node;
				node += nextOffset;
				jmp removeModifierLoop;
			}
			(*shortcutSystem).modifierAllocated = modifierAllocated;
			(*shortcutSystem).modifierNotInUseOffset = modifierNotInUseOffset;
		}
	}
	ret hasRemovedShortcut;
}
FINISHORTCUTSYSTEM(){
	const ModifierNode *current;
	const ModifierNode *wall;
	if(!shortcutSystem){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	wall = current + (*shortcutSystem).modifierAllocated;
	jmp freeShortcutStringLoop;
	freeShortcutStringLoop:{
		if(inc current < wall){
			if((*current).inUse){
				free((*current).string);
				popPointer((*current).stringToken);
			}
			jmp freeShortcutStringLoop;
		}
		setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
		free((*shortcutSystem).modifierStart);
		popPointer((*shortcutSystem).modifierToken);
		(*shortcutSystem).modifierSize = 0;
		(*shortcutSystem).modifierAllocated = 0;
		(*shortcutSystem).modifierNotInUseOffset = 0;
		(*shortcutSystem).modifierStart = NULL;
		(*shortcutSystem).modifierToken = 0;
		ret true;
	}
	#undef  MODIFIER_DATA_BLOCK_SIZE
}
SETCONFIGVARIABLES(){
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	getDoubleQuotation: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	}
	getSingleQuotation: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	}
	handleEscapeCharacter: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	checkComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	ignoreMultipleLineComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	}
	checkMultipleLineCommentEnd: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	}
	ignoreSingleLineComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	}
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch(jmpPoint){
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		}
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch(*instructionCurrent){
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	}
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch(matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer)){
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		}
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch(matchInteger(&statementCurrent, statementWall, integerPointer)){
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		}
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch(matchImageReturn){
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		}
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch(name0Return){
				off: /*-*/ brk;
			}
		}
		if(instructionStart == doInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, Do); jmp assessSubinstruction;
				off: /*----------------*/ /*-----------------------------*/ brk;
			}
		}
		if(instructionStart == grabKeycodeInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabKeycode); jmp assessSubinstruction;
				off: /*----------------*/ /*--------------------------------------*/ brk;
			}
		}
		if(instructionStart == grabButtonInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ applySubinstruction(execute, GrabButton); jmp assessSubinstruction;
				off: /*----------------*/ /*-------------------------------------*/ brk;
			}
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch(name0Return){
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch(name0Return){
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == setInstruction){
			switch(name0Return){
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			}
			switch(matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4)){
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			}
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*-*/ brk;
				off: /*----------------*/ brk;
			}
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch(*(inc n)){
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			}
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
IFGETC(){
	if(!system){
		ret EOF;
	}
	ret fgetc(system);
}
MATCHNAMELIST(){
	char *current = *statementCurrentReturn;
	uint value = 0;
	jmp matchNameLoop;
	matchNameLoop:{
		if(!findStringTreeString(stringTreeSystem, &current)){
			ret INVALID_NAME_NAME_LIST;
		}
		value |= !!(*stringTreeSystem).returnedCounter * (1 << ((*stringTreeSystem).returnedCounter - 1));
		jmp matchBar;
	}
	matchBar: switch(*(inc current)){
		to '\0': /*-*/ jmp endCheck;
		to '|': /*--*/ jmp advance;
		off: /*-----*/ jmp successful;
	}
	endCheck:{
		if(current >= statementWall){
			jmp successful;
		}
		jmp matchBar;
	}
	advance:{
		if(inc current >= statementWall){
			ret PREMATURE_END_NAME_LIST;
		}
		inc current;
		jmp matchNameLoop;
	}
	successful:{
		*valueReturn = value;
		*statementCurrentReturn = current;
		ret SUCCESS_NAME_LIST;
	}
}
MATCHINTEGER(){
	#define LEVEL0_JMP_POINT /*-*/ (0)
	#define LEVEL1_JMP_POINT /*-*/ (1)
	#define LEVEL2_JMP_POINT /*-*/ (2)
	char *current = *statementCurrent - 1;
	int64 number = 0;
	char op = '\0';
	JmpPoint jmpPoint;
	int64 i0 = 0;
	int64 i1 = 0;
	char o0 = '\0';
	char o1 = '\0';
	jmpPoint = LEVEL0_JMP_POINT;
	jmp matchWhitespace0Loop;
	matchWhitespace0Loop:{
		if(inc current >= statementWall){
			number = 0;
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace0Loop;
			to '\n': /*-*/ jmp matchWhitespace0Loop;
			to '\v': /*-*/ jmp matchWhitespace0Loop;
			to '\f': /*-*/ jmp matchWhitespace0Loop;
			to '\r': /*-*/ jmp matchWhitespace0Loop;
			to ' ': /*--*/ jmp matchWhitespace0Loop;
			off: /*-----*/ jmp matchInteger;
		}
	}
	matchInteger:{
		number = 0;
		dec current;
		jmp initialCheck;
	}
	initialCheck: switch(*(inc current)){
		to '0': /*-*/ /*--------*/ jmp formatCheck;
		to '1': /*-*/ dec current; jmp matchDecimalLoop;
		to '2': /*-*/ dec current; jmp matchDecimalLoop;
		to '3': /*-*/ dec current; jmp matchDecimalLoop;
		to '4': /*-*/ dec current; jmp matchDecimalLoop;
		to '5': /*-*/ dec current; jmp matchDecimalLoop;
		to '6': /*-*/ dec current; jmp matchDecimalLoop;
		to '7': /*-*/ dec current; jmp matchDecimalLoop;
		to '8': /*-*/ dec current; jmp matchDecimalLoop;
		to '9': /*-*/ dec current; jmp matchDecimalLoop;
		to '+': /*-*/ /*--------*/ jmp matchOperation;
		to '-': /*-*/ /*--------*/ jmp matchOperation;
		to '*': /*-*/ /*--------*/ jmp matchOperation;
		to '/': /*-*/ /*--------*/ jmp matchOperation;
		off: /*----*/ /*--------*/ jmp matchMacro;
	}
	formatCheck: switch(*(inc current)){
		to '\0': /*-*/ /*--------*/ jmp matchOperation;
		to '\t': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ /*--------*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ dec current; jmp matchOctalLoop;
		to '1': /*--*/ dec current; jmp matchOctalLoop;
		to '2': /*--*/ dec current; jmp matchOctalLoop;
		to '3': /*--*/ dec current; jmp matchOctalLoop;
		to '4': /*--*/ dec current; jmp matchOctalLoop;
		to '5': /*--*/ dec current; jmp matchOctalLoop;
		to '6': /*--*/ dec current; jmp matchOctalLoop;
		to '7': /*--*/ dec current; jmp matchOctalLoop;
		to 'B': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'b': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'X': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to 'x': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to '+': /*--*/ /*--------*/ jmp matchOperation;
		to '-': /*--*/ /*--------*/ jmp matchOperation;
		to '*': /*--*/ /*--------*/ jmp matchOperation;
		to '/': /*--*/ /*--------*/ jmp matchOperation;
		off: /*-----*/ /*--------*/ jmp nonNumber;
	}
	matchBinaryLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateBinary;
		to '1': /*--*/ jmp calculateBinary;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchOctalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateOctal;
		to '1': /*--*/ jmp calculateOctal;
		to '2': /*--*/ jmp calculateOctal;
		to '3': /*--*/ jmp calculateOctal;
		to '4': /*--*/ jmp calculateOctal;
		to '5': /*--*/ jmp calculateOctal;
		to '6': /*--*/ jmp calculateOctal;
		to '7': /*--*/ jmp calculateOctal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchDecimalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateDecimal;
		to '1': /*--*/ jmp calculateDecimal;
		to '2': /*--*/ jmp calculateDecimal;
		to '3': /*--*/ jmp calculateDecimal;
		to '4': /*--*/ jmp calculateDecimal;
		to '5': /*--*/ jmp calculateDecimal;
		to '6': /*--*/ jmp calculateDecimal;
		to '7': /*--*/ jmp calculateDecimal;
		to '8': /*--*/ jmp calculateDecimal;
		to '9': /*--*/ jmp calculateDecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchHexadecimalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateHexadecimal;
		to '1': /*--*/ jmp calculateHexadecimal;
		to '2': /*--*/ jmp calculateHexadecimal;
		to '3': /*--*/ jmp calculateHexadecimal;
		to '4': /*--*/ jmp calculateHexadecimal;
		to '5': /*--*/ jmp calculateHexadecimal;
		to '6': /*--*/ jmp calculateHexadecimal;
		to '7': /*--*/ jmp calculateHexadecimal;
		to '8': /*--*/ jmp calculateHexadecimal;
		to '9': /*--*/ jmp calculateHexadecimal;
		to 'A': /*--*/ jmp calculateHexadecimal;
		to 'B': /*--*/ jmp calculateHexadecimal;
		to 'C': /*--*/ jmp calculateHexadecimal;
		to 'D': /*--*/ jmp calculateHexadecimal;
		to 'E': /*--*/ jmp calculateHexadecimal;
		to 'F': /*--*/ jmp calculateHexadecimal;
		to 'a': /*--*/ jmp calculateHexadecimal;
		to 'b': /*--*/ jmp calculateHexadecimal;
		to 'c': /*--*/ jmp calculateHexadecimal;
		to 'd': /*--*/ jmp calculateHexadecimal;
		to 'e': /*--*/ jmp calculateHexadecimal;
		to 'f': /*--*/ jmp calculateHexadecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchMacro:{
		if(!findStringTreeString(&macroStringTreeSystem, &current)){
			jmp nonNumber;
		}
		if(macroStringTreeSystem.returnedCounter < 5){
			number = macroStringTreeSystem.returnedCounter;
			inc number;
		}elif(macroStringTreeSystem.returnedCounter < 9){
			number = macroStringTreeSystem.returnedCounter - 5;
		}elif(macroStringTreeSystem.returnedCounter < 11){
			number = macroStringTreeSystem.returnedCounter - 9;
		}elif(macroStringTreeSystem.returnedCounter < 15){
			number = macroStringTreeSystem.returnedCounter - 11;
		}elif(macroStringTreeSystem.returnedCounter < 17){
			number = macroStringTreeSystem.returnedCounter - 15;
		}else{
			number = 0;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			to '+': /*--*/ jmp matchOperation;
			to '-': /*--*/ jmp matchOperation;
			to '*': /*--*/ jmp matchOperation;
			to '/': /*--*/ jmp matchOperation;
			off: /*-----*/ jmp nonNumber;
		}
	}
	calculateBinary:{
		const int copy = number;
		number = number * 2 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchBinaryLoop;
	}
	calculateOctal:{
		const int copy = number;
		number = number * 8 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchOctalLoop;
	}
	calculateDecimal:{
		const int copy = number;
		number = number * 10 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchDecimalLoop;
	}
	calculateHexadecimal:{
		const int copy = number;
		number = number * 16 + *current - (*current >= '0') * 48 - (*current >= 'A') * 7 - (*current >= 'a') * 32;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchHexadecimalLoop;
	}
	matchWhitespace1Loop:{
		if(inc current >= statementWall){
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			off: /*-----*/ jmp matchOperation;
		}
	}
	matchOperation: switch(*current){
		to '+': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '-': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '*': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '/': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		off: /*----*/ op = '\0'; /*-----*/ jmp matchOperationReturnPoint;
	}
	matchOperationReturnPoint: switch(jmpPoint){
		to LEVEL0_JMP_POINT: /*-*/ jmp switchOperation0;
		to LEVEL1_JMP_POINT: /*-*/ jmp switchOperation1;
		off: /*-----------------*/ jmp switchOperation2;
	}
	switchOperation0: switch(op){
		to '\0': /*-*/ jmp level0;
		to '+': /*--*/ jmp level1;
		to '-': /*--*/ jmp level1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	}
	switchOperation1: switch(op){
		to '\0': /*-*/ jmp level1End;
		to '+': /*--*/ jmp level1FoundLevel1;
		to '-': /*--*/ jmp level1FoundLevel1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	}
	switchOperation2: switch(op){
		to '\0': /*-*/ jmp level2End;
		to '+': /*--*/ jmp level2FoundLevel1;
		to '-': /*--*/ jmp level2FoundLevel1;
		to '*': /*--*/ jmp level2FoundLevel2;
		to '/': /*--*/ jmp level2FoundLevel2;
	}
	level0:{
		i0 = number;
		jmp validNumber;
	}
	level1:{
		i0 = number;
		o0 = op;
		jmpPoint = LEVEL1_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level2:{
		i1 = number;
		o1 = op;
		jmpPoint = LEVEL2_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level1End:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp validNumber;
	}
	level1FoundLevel1:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp matchWhitespace0Loop;
	}
	level2End:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch(o0){
			to '\0': /*-*/ i0  = i1; jmp validNumber;
			to '+': /*--*/ i0 += i1; jmp validNumber;
			to '-': /*--*/ i0 -= i1; jmp validNumber;
		}
	}
	level2FoundLevel1:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch(o0){
			to '\0': /*-*/ o1 = '\0'; /*-*/ number = i1; jmp level1;
			to '+': /*--*/ i0 += i1; /*--*/ number = i0; jmp level1;
			to '-': /*--*/ i0 -= i1; /*--*/ number = i0; jmp level1;
		}
	}
	level2FoundLevel2:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		o1 = op;
		jmp matchWhitespace0Loop;
	}
	validNumber:{
		*statementCurrent = current + 1;
		*returnValue = i0;
		ret VALID_NUMBER_NUMBER;
	}
	nonNumber:{
		*statementCurrent = current + 1;
		ret NON_NUMBER_NUMBER;
	}
	overflownNumber:{
		*statementCurrent = current + 1;
		ret OVERFLOWN_NUMBER_NUMBER;
	}
	dividedByZeroNumber:{
		*statementCurrent = current + 1;
		ret DIVIDED_BY_ZERO_NUMBER;
	}
	#undef  LEVEL2_JMP_POINT
	#undef  LEVEL1_JMP_POINT
	#undef  LEVEL0_JMP_POINT
}
MATCHSTRING(){
	#define STRING_BLOCK_SIZE /*-*/ (1024)
	uint size = STRING_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched string pointer", iFree);
	uint allocated = 0;
	char *dataCurrent = dataStart;
	char *current = *statementCurrent;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp copyStringLoop;
	}
	copyStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += STRING_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *current;
		inc allocated;
		if(*current){
			inc current;
			inc dataCurrent;
			jmp copyStringLoop;
		}
		inc current;
		jmp trimMemory;
	}
	trimMemory:{
		void *const temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(temp){
			dataStart = temp;
		}
		jmp returnValidString;
	}
	returnValidString:{
		*statementCurrent = current;
		*stringReturn = dataStart;
		*stringToken = dataToken;
		ret true;
	}
	#undef  STRING_BLOCK_SIZE
}
MATCHIMAGE(){
	#define FILE_HEADER_SIZE /*---*/ (14)
	#define BITMAPCOREHEADER /*---*/ (12)
	#define OS22XBITMAPHEADER /*--*/ (64)
	#define BITMAPINFOHEADER /*---*/ (40)
	#define BITMAPV2INFOHEADER /*-*/ (52)
	#define BITMAPV3INFOHEADER /*-*/ (56)
	#define BITMAPV4HEADER /*-----*/ (108)
	#define BITMAPV5HEADER /*-----*/ (124)
	#define BI_RGB /*-------------*/ (0)
	#define BI_RLE8 /*------------*/ (1)
	#define BI_RLE4 /*------------*/ (2)
	#define BI_BITFIELDS /*-------*/ (3)
	#define BI_JPEG /*------------*/ (4)
	#define BI_PNG /*-------------*/ (5)
	#define BI_ALPHABITFIELDS /*--*/ (6)
	#define BI_CMYK /*------------*/ (11)
	#define BI_CMYKRLE8 /*--------*/ (12)
	#define BI_CMYKRLE4 /*--------*/ (13)
	FILE *file = NULL;
	uint32 fileToken = 0;
	uint8 b;
	uint8 m;
	uint32 headerSize;
	int32 width;
	int32 height;
	uint16 depth;
	uint32 compression;
	uint32 *data = NULL;
	uint32 dataToken = 0;
	uint8 returnValue;
	*errorMessage = NULL;
	jmp openFile;
	openFile:{
		file = fopen(path, "rb");
		fileToken = pushPointer(file, "image file", fclose);
		if(!file){
			returnValue = CANNOT_OPEN_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readHeaders;
	}
	readHeaders:{
		uint8 header[FILE_HEADER_SIZE + BITMAPINFOHEADER];
		if(fread(header, sizeof(uint8), FILE_HEADER_SIZE + 34, file) != FILE_HEADER_SIZE + 34){
			returnValue = CANNOT_READ_MATCH_IMAGE;
			jmp failedImage;
		}
		b /*-----------*/ = *(uint8  *)(header + 0);
		m /*-----------*/ = *(uint8  *)(header + 1);
		headerSize /*--*/ = *(uint32 *)(header + 14);
		width /*-------*/ = *( int32 *)(header + 18);
		height /*------*/ = *( int32 *)(header + 22);
		depth /*-------*/ = *(uint16 *)(header + 28);
		compression /*-*/ = *(uint32 *)(header + 30);
		jmp queryFileFormat;
	}
	queryFileFormat:{
		if(b != 'B' or m != 'M'){
			returnValue = UNSUPPORTED_FORMAT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp queryHeaderSupport;
	}
	queryHeaderSupport: switch(headerSize){
		to BITMAPCOREHEADER: /*---*/ *errorMessage = "BITMAPCOREHEADER header not supported"; /*--*/ jmp printHeaderError;
		to OS22XBITMAPHEADER: /*--*/ *errorMessage = "OS22XBITMAPHEADER header not supported"; /*-*/ jmp printHeaderError;
		to BITMAPINFOHEADER: /*---*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV2INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV3INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV4HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV5HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		off: /*-------------------*/ *errorMessage = "unrecognized header"; /*--------------------*/ jmp printHeaderError;
	}
	printHeaderError:{
		returnValue = BAD_HEADER_MATCH_IMAGE;
		jmp failedImage;
	}
	queryDepth: switch(depth){
		to 1: /*--*/ *errorMessage = "1 bit depth not supported"; /*---*/ jmp printDepthError;
		to 4: /*--*/ *errorMessage = "4 bit depth not supported"; /*---*/ jmp printDepthError;
		to 8: /*--*/ *errorMessage = "8 bit depth not supported"; /*---*/ jmp printDepthError;
		to 16: /*-*/ *errorMessage = "16 bit depth not supported"; /*--*/ jmp printDepthError;
		to 24: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		to 32: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		off: /*---*/ *errorMessage = "unknown depth not supported"; /*-*/ jmp printDepthError;
	}
	printDepthError:{
		returnValue = BAD_DEPTH_MATCH_IMAGE;
		jmp failedImage;
	}
	queryCompression: switch(compression){
		to BI_RGB: /*------------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_RLE8: /*-----------*/ *errorMessage = "BI_RLE8 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_RLE4: /*-----------*/ *errorMessage = "BI_RLE4 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_BITFIELDS: /*------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_JPEG: /*-----------*/ *errorMessage = "BI_JPEG compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_PNG: /*------------*/ *errorMessage = "BI_PNG compression not supported"; /*------------*/ jmp printCompressionError;
		to BI_ALPHABITFIELDS: /*-*/ *errorMessage = "BI_ALPHABITFIELDS compression not supported"; /*-*/ jmp printCompressionError;
		to BI_CMYK: /*-----------*/ *errorMessage = "BI_CMYK compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_CMYKRLE8: /*-------*/ *errorMessage = "BI_CMYKRLE8 compression not supported"; /*-------*/ jmp printCompressionError;
		to BI_CMYKRLE4: /*-------*/ *errorMessage = "BI_CMYKRLE4 compression not supported"; /*-------*/ jmp printCompressionError;
		off: /*------------------*/ *errorMessage = "unrecognized compression used"; /*---------------*/ jmp printCompressionError;
	}
	printCompressionError:{
		returnValue = BAD_COMPRESSION_MATCH_IMAGE;
		jmp failedImage;
	}
	queryHeight:{
		if(height < 0){
			returnValue = UNSUPPORTED_HEIGHT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp setupImage;
	}
	setupImage:{
		if(fseek(file, FILE_HEADER_SIZE + headerSize, SEEK_SET)){
			returnValue = BAD_SIZE_MATCH_IMAGE;
			jmp failedImage;
		}
		(*image).width = width;
		(*image).height = height;
		(*image).dataSize = width * height * sizeof(uint32);
		data = malloc((*image).dataSize * sizeof(uint8));
		dataToken = pushPointer(data, "image data pointer", iFree);
		if(!data){
			returnValue = FAILED_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readPixels;
	}
	readPixels:{
		const uint32 amount = (depth * width + 31) / 8 / width;
		const uint widthTwice = 2 * width;
		uint32 *const start = data + (height - 1) * width;
		uint32 *current = start;
		uint multipleCounter = 0;
		uint32 *currentWall = current + width;
		jmp readRowLoop;
		readRowLoop:{
			if(fread(current, sizeof(uint8), amount, file) != amount){
				if(current == start){
					returnValue = BAD_PIXELS_MATCH_IMAGE;
					jmp failedImage;
				}
				returnValue = BAD_IMAGE_MATCH_IMAGE;
				jmp failedImage;
			}
			if(depth == 24){
				*current |= 0xFF000000;
			}
			multipleCounter += amount;
			multipleCounter -= (multipleCounter > 4) * 4;
			if(inc current < currentWall){
				jmp readRowLoop;
			}
			if((current -= widthTwice) >= data){
				fseek(file, 4 - multipleCounter, SEEK_CUR);
				multipleCounter = 0;
				currentWall -= width;
				jmp readRowLoop;
			}
			jmp successfulImage;
		}
	}
	successfulImage:{
		fclose(file);
		popPointer(fileToken);
		(*image).dataStart = data;
		(*image).dataToken = dataToken;
		ret SUCCESS_MATCH_IMAGE;
	}
	failedImage:{
		free(data);
		popPointer(dataToken);
		if(file){
			fclose(file);
			popPointer(fileToken);
		}
		ret returnValue;
	}
	#undef  BI_CMYKRLE4
	#undef  BI_CMYKRLE8
	#undef  BI_CMYK
	#undef  BI_ALPHABITFIELDS
	#undef  BI_PNG
	#undef  BI_JPEG
	#undef  BI_BITFIELDS
	#undef  BI_RLE4
	#undef  BI_RLE8
	#undef  BI_RGB
	#undef  BITMAPV5HEADER
	#undef  BITMAPV4HEADER
	#undef  BITMAPV3INFOHEADER
	#undef  BITMAPV2INFOHEADER
	#undef  BITMAPINFOHEADER
	#undef  OS22XBITMAPHEADER
	#undef  BITMAPCOREHEADER
	#undef  FILE_HEADER_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch(origin){
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	}
	matchCommand: switch(command){
		to NONE_COMMAND: /*----*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*-*/ jmp executeCommand;
		to RESTART_COMMAND: /*-*/ jmp restartCommand;
		to EXIT_COMMAND: /*----*/ jmp exitCommand;
		off: /*----------------*/ jmp unrecognizedCommand;
	}
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
UNGRABSHORTCUTS(){
	if(!connection){
		ret false;
	}
	if(keycodeShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_key(connection, XCB_GRAB_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	if(buttonShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_button(connection, XCB_BUTTON_INDEX_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	ret true;
}
FREECONFIGVARIABLES(){
	ret;
}
SETMEMORY(){
	switch(perByteAmount){
		to sizeof(uint8): /*--*/ jmp perByte;
		to sizeof(uint16): /*-*/ jmp perTwoBytes;
		to sizeof(uint32): /*-*/ jmp perFourBytes;
		to sizeof(uint64): /*-*/ jmp perEightBytes;
		off: /*---------------*/ ret;
	}
	perByte:{
		const uint8 value8 = value;
		uint8 *current = destinationStart;
		uint8 *const wall = current + itemAmount;
		jmp perByteLoop;
		perByteLoop:{
			if(current < wall){
				*current = value8;
				inc current;
				jmp perByteLoop;
			}
			ret;
		}
	}
	perTwoBytes:{
		const uint16 value16 = value;
		uint16 *current = destinationStart;
		uint16 *const wall = current + itemAmount;
		jmp perTwoBytesLoop;
		perTwoBytesLoop:{
			if(current < wall){
				*current = value16;
				inc current;
				jmp perTwoBytesLoop;
			}
			ret;
		}
	}
	perFourBytes:{
		const uint32 value32 = value;
		uint32 *current = destinationStart;
		uint32 *const wall = current + itemAmount;
		jmp perFourBytesLoop;
		perFourBytesLoop:{
			if(current < wall){
				*current = value32;
				inc current;
				jmp perFourBytesLoop;
			}
			ret;
		}
	}
	perEightBytes:{
		const uint64 value64 = value;
		uint64 *current = destinationStart;
		uint64 *const wall = current + itemAmount;
		jmp perEightBytesLoop;
		perEightBytesLoop:{
			if(current < wall){
				*current = value64;
				inc current;
				jmp perEightBytesLoop;
			}
			ret;
		}
	}
}
COPYMEMORY(){
	const void *sourceCurrent;
	const void *sourceWall;
	void *destinationCurrent;
	bool flag;
	if(!sourceStart or !destinationStart or !byteAmount){
		ret;
	}
	sourceCurrent = sourceStart;
	destinationCurrent = destinationStart;
	jmp checkMisalignment;
	checkMisalignment:{
		uint misalignmentAmount = (uint64)destinationCurrent & (sizeof(uint64) - 1);
		if(misalignmentAmount and (uint64)sourceCurrent & (sizeof(uint64) - 1)){
			if(misalignmentAmount > byteAmount){
				misalignmentAmount = byteAmount;
			}
			sourceWall = (uint8 *)sourceCurrent + misalignmentAmount;
			byteAmount -= misalignmentAmount;
			flag = true;
			jmp smallLoop;
		}
		jmp preLargeLoop;
	}
	preLargeLoop:{
		sourceWall = (uint64 *)sourceCurrent + byteAmount / sizeof(uint64);
		flag = false;
		jmp largeLoop;
	}
	largeLoop:{
		if((uint64 *)sourceCurrent < (uint64 *)sourceWall){
			*(uint64 *)destinationCurrent = *(uint64 *)sourceCurrent;
			sourceCurrent = (uint64 *)sourceCurrent + 1;
			destinationCurrent = (uint64 *)destinationCurrent + 1;
			jmp largeLoop;
		}
		sourceWall = (uint8 *)sourceCurrent + (byteAmount & (sizeof(uint64) - 1));
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)sourceCurrent < (uint8 *)sourceWall){
			*(uint8 *)destinationCurrent = *(uint8 *)sourceCurrent;
			sourceCurrent = (uint8 *)sourceCurrent + 1;
			destinationCurrent = (uint8 *)destinationCurrent + 1;
			jmp smallLoop;
		}
		if(flag){
			jmp preLargeLoop;
		}
		ret;
	}
}
SHIFTMEMORY(){
	uint amountToAdd;
	void *current;
	void *wall;
	int misalignmentAmount;
	bool flag;
	int nextItemOffset;
	if(!start or byteAmount < 1 or !byteOffset){
		ret;
	}
	nextItemOffset = 1 - (byteOffset > 0) * 2;
	current = (uint8 *)start + (byteOffset > 0) * byteAmount;
	if((misalignmentAmount = (uint64)start & (sizeof(uint64) - 1))){
		if(misalignmentAmount > byteAmount){
			misalignmentAmount = byteAmount;
		}
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint8)) * sizeof(uint8);
		current = (uint8 *)current - amountToAdd;
		wall = (uint8 *)current + nextItemOffset * misalignmentAmount;
		byteAmount -= misalignmentAmount;
		flag = true;
		jmp shiftSmallLoop;
	}
	jmp preShiftLargeLoop;
	preShiftLargeLoop:{
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint64)) * sizeof(uint64);
		current = (uint8 *)current - amountToAdd;
		wall = (uint64 *)current + nextItemOffset * (byteAmount / sizeof(uint64));
		flag = false;
		jmp shiftLargeLoop;
	}
	shiftLargeLoop:{
		if((uint64 *)current != (uint64 *)wall){
			*(uint64 *)((uint8 *)current + byteOffset) = *(uint64 *)current;
			current = (uint64 *)current + nextItemOffset;
			jmp shiftLargeLoop;
		}
		current = (uint8 *)current + amountToAdd;
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint8)) * sizeof(uint8);
		current = (uint8 *)current - amountToAdd;
		wall = (uint8 *)current + nextItemOffset * (byteAmount & (sizeof(uint64) - 1));
		jmp shiftSmallLoop;
	}
	shiftSmallLoop:{
		if((uint8 *)current != (uint8 *)wall){
			*(uint8 *)((uint8 *)current + byteOffset) = *(uint8 *)current;
			current = (uint8 *)current + nextItemOffset;
			jmp shiftSmallLoop;
		}
		current = (uint8 *)current + amountToAdd;
		if(flag){
			jmp preShiftLargeLoop;
		}
		ret;
	}
}
COMPAREMEMORY(){
	const void *memory0Current = memory0;
	const void *memory0Wall = (uint64 *)memory0Current + byteAmount / sizeof(uint64);
	const void *memory1Current = memory1;
	jmp largeLoop;
	largeLoop:{
		if((uint64 *)memory0Current < (uint64 *)memory0Wall){
			if(*(uint64 *)memory0Current != *(uint64 *)memory1Current){
				ret false;
			}
			memory0Current = (uint64 *)memory0Current + 1;
			memory1Current = (uint64 *)memory1Current + 1;
			jmp largeLoop;
		}
		memory0Wall = (uint8 *)memory0Current + (byteAmount & (sizeof(uint64) - 1));
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)memory0Current < (uint8 *)memory0Wall){
			if(*(uint8 *)memory0Current != *(uint8 *)memory1Current){
				ret false;
			}
			memory0Current = (uint8 *)memory0Current + 1;
			memory1Current = (uint8 *)memory1Current + 1;
			jmp smallLoop;
		}
		ret true;
	}
}
FINDSTRINGLENGTH(){
	const uint8 *current = string;
	jmp advanceStringPointerLoop;
	advanceStringPointerLoop:{
		if(*current){
			inc current;
			jmp advanceStringPointerLoop;
		}
		ret current - (uint8 *)string;
	}
}
FINDSUBSTRING(){
	const char *stringCurrent;
	const char *stringWall;
	char substringStartingCharacter;
	if(!string or !stringLength or !substring or !substringLength){
		ret NULL;
	}
	stringCurrent = string;
	stringWall = stringCurrent + stringLength;
	substringStartingCharacter = *substring;
	jmp findSubstringLoop;
	findSubstringLoop:{
		if(stringCurrent < stringWall){
			if(*stringCurrent == substringStartingCharacter){
				if(stringWall - stringCurrent < substringLength){
					ret NULL;
				}
				if(compareMemory(stringCurrent, substring, substringLength)){
					ret (void *)stringCurrent;
				}
			}
			inc stringCurrent;
			jmp findSubstringLoop;
		}
		ret NULL;
	}
}
UTF8TOUCS2(){
	uint8 *utf8Current = utf8Start;
	uint8 *const utf8Wall = utf8Current + utf8Length;
	uint16 *ucs2Current = ucs2Start;
	uint16 *const ucs2Wall = ucs2Current + ucs2Length;
	jmp translateUTF8ToUCS2Loop;
	translateUTF8ToUCS2Loop:{
		if(utf8Current < utf8Wall and ucs2Current < ucs2Wall){
			uint16 newUCS2;
			uint8 byte1 = *utf8Current;
			if(byte1 < b(10000000)){
				newUCS2 = byte1;
				byte1 = '\0';
				inc utf8Current;
			}elif((byte1 & b(11100000)) == b(11000000)){
				const uint8 byte2 = *(utf8Current + 1);
				if((byte2 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00011111)) << 6) | (byte2 & b(00111111));
					byte1 = '\0';
					utf8Current += 2;
				}else{
					inc utf8Current;
				}
			}elif((byte1 & b(11110000)) == b(11100000)){
				const uint8 byte2 = *(utf8Current + 1);
				const uint8 byte3 = *(utf8Current + 2);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00001111)) << 12) | ((byte2 & b(00111111)) << 6) | (byte3 & b(00111111));
					byte1 = '\0';
					utf8Current += 3;
				}else{
					inc utf8Current;
				}
			}elif((byte1 & b(11111000)) == b(11110000)){
				const uint8 byte2 = *(utf8Current + 1);
				const uint8 byte3 = *(utf8Current + 2);
				const uint8 byte4 = *(utf8Current + 3);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000) and (byte4 & b(11000000)) == b(10000000)){
					utf8Current += 4;
				}else{
					inc utf8Current;
				}
			}else{
				inc utf8Current;
			}
			if(!byte1){
				*ucs2Current = (newUCS2 << 8) | (newUCS2 >> 8);
				inc ucs2Current;
			}
			jmp translateUTF8ToUCS2Loop;
		}
		ret ucs2Current - ucs2Start;
	}
}
INTERSECTS(){
	ret x0 + width0 > x1 and x0 < x1 + width1 and y0 + height0 > y1 and y0 < y1 + height1;
}
GETINTERSECTION(){
	const int leftX = x0 > x1? x0 : x1;
	const int topY = y0 > y1? y0 : y1;
	const int rightX = x0 + width0 < x1 + width1? x0 + width0 : x1 + width1;
	const int bottomY = y0 + height0 < y1 + height1? y0 + height0 : y1 + height1;
	const int intersectionWidth = rightX > leftX? rightX - leftX : 0;
	const int intersectionHeight = bottomY > topY? bottomY - topY : 0;
	if(xReturn) /*------*/ *xReturn = leftX;
	if(yReturn) /*------*/ *yReturn = topY;
	if(widthReturn) /*--*/ *widthReturn = intersectionWidth;
	if(heightReturn) /*-*/ *heightReturn = intersectionHeight;
	ret;
}
LOADFILE(){
	#define DATA_BLOCK_SIZE /*-*/ (1024)
	FILE *file;
	uint32 token;
	uint dataAllocated;
	uint dataSize;
	char *dataStart;
	char *dataCurrent;
	uint32 dataToken;
	if(!path or !loadedFileReturn){
		ret false;
	}
	file = fopen(path, "r");
	token = pushPointer(file, "loadFile() file", fclose);
	if(!file){
		ret false;
	}
	dataAllocated = 0;
	dataSize = 0;
	dataStart = NULL;
	dataCurrent = dataStart;
	dataToken = 0;
	jmp allocateMemory;
	allocateMemory:{
		uint offset = 0;
		void *temp;
		if(dataCurrent){
			offset = dataCurrent - dataStart;
		}
		dataSize += DATA_BLOCK_SIZE;
		temp = realloc(dataStart, dataSize * sizeof(char));
		if(!dataToken){
			dataToken = pushPointer(temp, "loaded system file data", iFree);
		}else{
			updatePointer(dataToken, temp);
		}
		if(!temp){
			free(dataStart);
			popPointer(dataToken);
			fclose(file);
			popPointer(token);
			ret false;
		}
		dataStart = temp;
		dataCurrent = dataStart + offset;
		jmp loadFileSegmentLoop;
	}
	loadFileSegmentLoop:{
		const uint amountRead = fread(dataCurrent, sizeof(char), DATA_BLOCK_SIZE, file);
		dataAllocated += amountRead;
		if(amountRead == DATA_BLOCK_SIZE){
			jmp allocateMemory;
		}
		dataSize = dataAllocated;
		jmp trimMemory;
	}
	trimMemory:{
		if(dataSize){
			void *const temp = realloc(dataStart, dataSize * sizeof(char));
			updatePointer(dataToken, temp);
			if(temp){
				dataStart = temp;
			}
		}
		fclose(file);
		popPointer(token);
		(*loadedFileReturn).dataSize = dataSize;
		(*loadedFileReturn).dataStart = dataStart;
		(*loadedFileReturn).dataToken = dataToken;
		ret true;
	}
	#undef  DATA_BLOCK_SIZE
}
SPAWNPROCESS(){
	#define FORK_FAILURE /*-------*/ (-1)
	#define CHILD_FORK_PROCESS /*-*/ (0)
	#define SETSID_FAILURE /*-----*/ (-1)
	#define SETGID_FAILURE /*-----*/ (-1)
	#define SETUID_FAILURE /*-----*/ (-1)
	#define CHDIR_FAILURE /*------*/ (-1)
	if(!string){
		ret;
	}
	switch(fork()){
		to FORK_FAILURE:{
			printTitledError("fork error", "could not execute shell command");
			ret;
		}
		to CHILD_FORK_PROCESS:{
			char *env;
			if(setsid() == SETSID_FAILURE){
				printTitledError("fork error", "could not set group leader");
				exit(EXIT_SUCCESS);
			}
			dropPermissions(&permissionSystem);
			env = getenv("HOME");
			if(env and chdir(env) == CHDIR_FAILURE){
				printTitledError("fork error", "could not change directory to home");
			}
			execl("/bin/sh", "sh", "-c", string, NULL);
			exit(EXIT_SUCCESS);
		}
		off:{
			ret;
		}
	}
	#undef  CHDIR_FAILURE
	#undef  SETUID_FAILURE
	#undef  SETGID_FAILURE
	#undef  SETSID_FAILURE
	#undef  CHILD_FORK_PROCESS
	#undef  FORK_FAILURE
}
CREATECIRCLE(){
	const uint width = radius * 2 + 1;
	const uint height = width;
	const int r2 = radius * radius;
	uint32 *data = malloc(width * height * sizeof(uint32));
	uint32 token = pushPointer(data, "createCorner() data pointer", iFree);
	int y = -radius;
	uint32 *currentData = data;
	if(!data){
		ret false;
	}
	jmp yLoop;
	yLoop:{
		if(y <= radius){
			const int y2 = y * y;
			int x = -radius;
			jmp xLoop;
			xLoop:{
				if(x <= radius){
					const int x2y2 = x * x + y2;
					if(x2y2 <= r2){
						*currentData = foreground;
					}else{
						*currentData = background;
					}
					inc currentData;
					inc x;
					jmp xLoop;
				}
				inc y;
				jmp yLoop;
			}
		}
		(*image).x = 0;
		(*image).y = 0;
		(*image).width = width;
		(*image).height = height;
		(*image).dataStart = data;
		(*image).dataToken = token;
		(*image).dataSize = width * height * sizeof(uint32);
		ret true;
	}
}
COMPOSITEIMAGES(){
	int intersectionWidth;
	int intersectionHeight;
	uint32 *sourceCurrent;
	uint32 *sourceWidthWall;
	uint32 *sourceWall;
	uint32 *destinationCurrent;
	if(sourceX < 0 or sourceY < 0 or sourceX >= (*source).width or sourceY >= (*source).height){
		ret;
	}
	{
		const int b1lx = 0;
		const int b1ty = 0;
		const int b1rx = (*destination).width;
		const int b1by = (*destination).height;
		const int b2lx = destinationX;
		const int b2ty = destinationY;
		const int b2rx = b2lx + (*source).width - sourceX;
		const int b2by = b2ty + (*source).height - sourceY;
		intersectionWidth = (b1rx < b2rx? b1rx : b2rx) - (b1lx > b2lx? b1lx : b2lx);
		intersectionHeight = (b1by < b2by? b1by : b2by) - (b1ty > b2ty? b1ty : b2ty);
		if(intersectionWidth < 1 or intersectionWidth < 1){
			ret;
		}
	}
	sourceCurrent = (uint32 *)(*source).dataStart + sourceY * (*source).width + sourceX;
	if(destinationX < 0){
		sourceCurrent -= destinationX;
		destinationX = 0;
	}
	if(destinationY < 0){
		sourceCurrent -= destinationY * (*source).width;
		destinationY = 0;
	}
	sourceWidthWall = sourceCurrent + intersectionWidth;
	sourceWall = sourceCurrent + intersectionHeight * (*source).width;
	destinationCurrent = (uint32 *)(*destination).dataStart + destinationY * (*destination).width + destinationX;
	jmp yLoop;
	yLoop:{
		if(sourceCurrent < sourceWall){
			jmp xLoop;
			xLoop:{
				if(sourceCurrent < sourceWidthWall){
					operation(sourceCurrent, destinationCurrent);
					inc sourceCurrent;
					inc destinationCurrent;
					jmp xLoop;
				}
				sourceCurrent += (*source).width - intersectionWidth;
				sourceWidthWall += (*source).width;
				destinationCurrent += (*destination).width - intersectionWidth;
				jmp yLoop;
			}
		}
		ret;
	}
}
COMPOSITEIMAGESOVER(){
	const uint32 s = *source;
	const uint32 d = *destination;
	const uint64 a_a = s >> 24;
	if(a_a == 0xFF){
		*destination = s;
		ret;
	}
	if(a_a){
		const uint32 r_a = (s & 0x00FF0000) >> 16;
		const uint32 g_a = (s & 0x0000FF00) >> 8;
		const uint32 b_a = (s & 0x000000FF) >> 0;
		const uint32 a_b = d >> 24;
		const uint32 r_b = (d & 0x00FF0000) >> 16;
		const uint32 g_b = (d & 0x0000FF00) >> 8;
		const uint32 b_b = (d & 0x000000FF) >> 0;
		const uint32 a_0 = a_a + a_b * (0xFF - a_a) / 0xFF;
		const uint32 r = (r_a * a_a + r_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 g = (g_a * a_a + g_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 b = (b_a * a_a + b_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		*destination = (a_0 << 24) + ((r & 0x000000FF) << 16) + ((g & 0x000000FF) << 8) + ((b & 0x000000FF) << 0);
		ret;
	}
	ret;
}
COMPOSITEIMAGESAND(){
	if(!(*source >> 24)){
		*destination = 0x00000000;
		ret;
	}
	ret;
}
TWOPASSBOXBLUR(){
	uint32 *intermediateData;
	uint32 *kernelColumnRStart;
	uint32 *kernelColumnGStart;
	uint32 *kernelColumnBStart;
	uint32 *pixelRStart;
	uint32 *pixelGStart;
	uint32 *pixelBStart;
	if(boxSize == 1){
		ret;
	}
	intermediateData = malloc(width * height * sizeof(uint32));
	kernelColumnRStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnGStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnBStart = malloc(boxSize + 2 * width * sizeof(uint32));
	pixelRStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelGStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelBStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	{
		const int divisor = boxSize * boxSize;
		const int boxDistanceFromZero = boxSize >> 1;
		const int nBoxDistanceFromZero = -boxDistanceFromZero;
		const int widthMinusOne = width - 1;
		const int heightMinusOne = height - 1;
		const int heightMinusBoxSize = height - boxSize;
		uint32 *tx = destinationData;
		uint32 *txCopy = tx;
		uint32 *rx = intermediateData;
		uint32 r;
		uint32 g;
		uint32 b;
		jmp loop;
		loop:{
			uint32 *kernelColumnRCurrent = kernelColumnRStart;
			uint32 *kernelColumnGCurrent = kernelColumnGStart;
			uint32 *kernelColumnBCurrent = kernelColumnBStart;
			uint32 *kernelColumnRCurrentCopy = kernelColumnRStart;
			uint32 *kernelColumnGCurrentCopy = kernelColumnGStart;
			uint32 *kernelColumnBCurrentCopy = kernelColumnBStart;
			uint32 *pixelRCurrent = pixelRStart;
			uint32 *pixelGCurrent = pixelGStart;
			uint32 *pixelBCurrent = pixelBStart;
			uint32 *pixelRCurrentCopy = pixelRStart;
			uint32 *pixelGCurrentCopy = pixelGStart;
			uint32 *pixelBCurrentCopy = pixelBStart;
			int x = 0;
			int y = 0;
			{
				int kx = nBoxDistanceFromZero;
				r = 0;
				g = 0;
				b = 0;
				while(kx <= boxDistanceFromZero){
					int ky = nBoxDistanceFromZero;
					int usedX = x + kx;
					if(usedX < 0){
						usedX = 0;
					}
					*kernelColumnRCurrent = 0;
					*kernelColumnGCurrent = 0;
					*kernelColumnBCurrent = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						*kernelColumnRCurrent += *pixelRCurrent;
						*kernelColumnGCurrent += *pixelGCurrent;
						*kernelColumnBCurrent += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += *kernelColumnRCurrent;
					g += *kernelColumnGCurrent;
					b += *kernelColumnBCurrent;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
					inc kernelColumnRCurrent;
					inc kernelColumnGCurrent;
					inc kernelColumnBCurrent;
					inc kx;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
			}
			inc x;
			xFirstLoop:{
				int kx = boxDistanceFromZero;
				int ky = nBoxDistanceFromZero;
				int usedX = x + kx;
				if(usedX < 0){
					usedX = 0;
				}elif(usedX >= width){
					usedX = widthMinusOne;
				}
				r -= *kernelColumnRCurrentCopy;
				g -= *kernelColumnGCurrentCopy;
				b -= *kernelColumnBCurrentCopy;
				kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
				kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
				kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
				inc kernelColumnRCurrentCopy;
				inc kernelColumnGCurrentCopy;
				inc kernelColumnBCurrentCopy;
				{
					uint32 lr = 0;
					uint32 lg = 0;
					uint32 lb = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}elif(usedY >= height){
							usedY = heightMinusOne;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						lr += *pixelRCurrent;
						lg += *pixelGCurrent;
						lb += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += lr;
					g += lg;
					b += lb;
					*kernelColumnRCurrent = lr;
					*kernelColumnGCurrent = lg;
					*kernelColumnBCurrent = lb;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
				if(inc x < width){
					jmp xFirstLoop;
				}
			}
			inc y;
			yLoop:{
				uint32 *pr;
				uint32 *pg;
				uint32 *pb;
				int ky = boxDistanceFromZero;
				int usedY = y + ky;
				if(usedY < 0){
					usedY = 0;
				}elif(usedY >= height){
					usedY = heightMinusOne;
				}
				x = 0;
				{
					int kx = nBoxDistanceFromZero;
					kernelColumnRCurrent = kernelColumnRStart;
					kernelColumnGCurrent = kernelColumnGStart;
					kernelColumnBCurrent = kernelColumnBStart;
					kernelColumnRCurrentCopy = kernelColumnRStart;
					kernelColumnGCurrentCopy = kernelColumnGStart;
					kernelColumnBCurrentCopy = kernelColumnBStart;
					pixelRCurrent = pixelRCurrentCopy;
					pixelGCurrent = pixelGCurrentCopy;
					pixelBCurrent = pixelBCurrentCopy;
					pr = pixelRCurrent + boxSize;
					pg = pixelGCurrent + boxSize;
					pb = pixelBCurrent + boxSize;
					r = 0;
					g = 0;
					b = 0;
					tx += usedY * width;
					while(kx <= boxDistanceFromZero){
						int usedX = x + kx;
						uint32 color;
						if(usedX < 0){
							usedX = 0;
						}elif(usedX >= width){
							usedX = widthMinusOne;
						}
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						inc kernelColumnRCurrent;
						inc kernelColumnGCurrent;
						inc kernelColumnBCurrent;
						inc kx;
					}
					tx -= usedY * width;
					*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
					inc rx;
					inc x;
				}
				{
					int usedX = x + boxDistanceFromZero;
					usedY *= width;
					tx += usedY;
					xLoop:{
						uint32 color;
						if(usedX >= width){
							usedX = widthMinusOne;
						}
						kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
						kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
						kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
						r -= *kernelColumnRCurrentCopy;
						g -= *kernelColumnGCurrentCopy;
						b -= *kernelColumnBCurrentCopy;
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						inc kernelColumnRCurrentCopy;
						inc kernelColumnGCurrentCopy;
						inc kernelColumnBCurrentCopy;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
						inc rx;
						if(inc x < width){
							inc usedX;
							jmp xLoop;
						}
					}
					tx -= usedY;
				}
				if(inc y < height){
					inc pixelRCurrentCopy;
					inc pixelGCurrentCopy;
					inc pixelBCurrentCopy;
					jmp yLoop;
				}
			}
			if(txCopy == destinationData){
				tx = intermediateData;
				txCopy = tx;
				rx = destinationData;
				jmp loop;
			}
		}
	}
	free(intermediateData);
	free(kernelColumnRStart);
	free(kernelColumnGStart);
	free(kernelColumnBStart);
	free(pixelRStart);
	free(pixelGStart);
	free(pixelBStart);
	ret;
}
ROTATEIMAGE(){
	const int oldWidth = (*image).width;
	const int oldHeight = (*image).height;
	const int oldSize = (*image).dataSize;
	uint32 *newData;
	uint32 newDataToken;
	uint32 *current = (*image).dataStart;
	uint32 *const yWall = (void *)((uint8 *)current + oldSize);
	uint32 *xWall = current + oldWidth;
	int newWidth;
	int newHeight;
	uint32 *newDataCurrent;
	int newDataNextX;
	int newDataNextY;
	if(!rotation){
		ret true;
	}
	newData = malloc(oldSize * sizeof(uint8));
	newDataToken = pushPointer(newData, "rotateImage() new data pointer", iFree);
	if(!newData){
		printTitledError("memory allocation error", "could not allocate rotated image color data");
		ret false;
	}
	switch(rotation){
		to DEGREES_90_ROTATION: /*--*/ jmp rotate90Degrees;
		to DEGREES_180_ROTATION: /*-*/ jmp rotate180Degrees;
		to DEGREES_270_ROTATION: /*-*/ jmp rotate270Degrees;
		off: /*---------------------*/ ret false;
	}
	rotate90Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newWidth - 1;
		newDataNextX = newWidth;
		newDataNextY = -newHeight * newWidth - 1;
		jmp copyYAxisLoop;
	}
	rotate180Degrees:{
		newWidth = oldWidth;
		newHeight = oldHeight;
		newDataCurrent = newData + newHeight * newWidth - 1;
		newDataNextX = -1;
		newDataNextY = 0;
		jmp copyYAxisLoop;
	}
	rotate270Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newHeight * newWidth - newWidth;
		newDataNextX = -newWidth;
		newDataNextY = newHeight * newWidth + 1;
		jmp copyYAxisLoop;
	}
	copyYAxisLoop:{
		if(current < yWall){
			jmp copyXAxisLoop;
			copyXAxisLoop:{
				if(current < xWall){
					*newDataCurrent = *current;
					newDataCurrent += newDataNextX;
					inc current;
					jmp copyXAxisLoop;
				}
				newDataCurrent += newDataNextY;
				xWall += oldWidth;
				jmp copyYAxisLoop;
			}
		}
		jmp success;
	}
	success:{
		if(deletePreviousData){
			free((*image).dataStart);
			popPointer((*image).dataToken);
		}
		(*image).width = newWidth;
		(*image).height = newHeight;
		(*image).dataStart = newData;
		(*image).dataToken = newDataToken;
		ret true;
	}
}
XCB_SYNC(){
	xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_input_focus(connection), NULL);
	uint32 token = pushPointer(reply, "sync reply", iFree);
	free(reply);
	popPointer(token);
	ret !!reply;
}
GETTIMESTAMP(){
	uint offset;
	if(!event){
		jmp invalidTimestamp;
	}
	offset = 0;
	jmp checkEventValidity;
	checkEventValidity: switch((*event).response_type){
		to XCB_KEY_PRESS: /*---------*/ /*-------*/ jmp validTimestamp;
		to XCB_KEY_RELEASE: /*-------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_PRESS: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_RELEASE: /*----*/ /*-------*/ jmp validTimestamp;
		to XCB_MOTION_NOTIFY: /*-----*/ /*-------*/ jmp validTimestamp;
		to XCB_ENTER_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_LEAVE_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_PROPERTY_NOTIFY: /*---*/ offset = 2; jmp validTimestamp;
		to XCB_SELECTION_CLEAR: /*---*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_REQUEST: /*-*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_NOTIFY: /*--*/ /*-------*/ jmp validTimestamp;
		off: /*----------------------*/ /*-------*/ jmp invalidTimestamp;
	}
	invalidTimestamp:{
		ret XCB_CURRENT_TIME;
	}
	validTimestamp:{
		ret *(xcb_timestamp_t *)((*event).pad + offset);
	}
}
GETWINDOWCLASS(){
	jmp getWindowClass;
	getWindowClass:{
		xcb_get_window_attributes_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_window_attributes(connection, window), NULL);
		uint32 token = pushPointer(reply, "getWindowClass() get window attributes reply", iFree);
		if(reply){
			const uint8 class = (*reply)._class;
			free(reply);
			popPointer(token);
			switch(class){
				to XCB_WINDOW_CLASS_COPY_FROM_PARENT: /*-*/ jmp getWindowParent;
				to XCB_WINDOW_CLASS_INPUT_OUTPUT: /*-----*/ ret XCB_WINDOW_CLASS_INPUT_OUTPUT;
				to XCB_WINDOW_CLASS_INPUT_ONLY: /*-------*/ ret XCB_WINDOW_CLASS_INPUT_ONLY;
				off: /*----------------------------------*/ ret XCB_WINDOW_CLASS_COPY_FROM_PARENT;
			}
		}
		jmp returnInconclusiveClass;
	}
	getWindowParent:{
		xcb_query_tree_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_tree(connection, window), NULL);
		uint32 token = pushPointer(reply, "getWindowClass() query tree reply", iFree);
		if(reply){
			const xcb_window_t parent = (*reply).parent;
			free(reply);
			popPointer(token);
			if(parent != window){
				window = parent;
				jmp getWindowClass;
			}
		}
		jmp returnInconclusiveClass;
	}
	returnInconclusiveClass:{
		ret XCB_WINDOW_CLASS_COPY_FROM_PARENT;
	}
}
GETFOCUSEDWINDOW(){
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_input_focus_cookie_t inputFocusCookie;
	xcb_window_t window = XCB_NONE;
	jmp getCookies;
	getCookies:{
		propertyCookie = xcb_get_property_unchecked(connection, false, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, 0, 1);
		inputFocusCookie = xcb_get_input_focus_unchecked(connection);
		jmp getActiveWindow;
	}
	getActiveWindow:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, propertyCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get property reply", iFree);
		bool found = false;
		if(reply){
			if(xcb_get_property_value_length(reply) == sizeof(xcb_window_t)){
				window = *(xcb_window_t *)xcb_get_property_value(reply);
				found = true;
			}
			free(reply);
			popPointer(token);
			if(found){
				xcb_discard_reply(connection, inputFocusCookie);
				ret window;
			}
		}
		jmp getFocusedWindow;
	}
	getFocusedWindow:{
		xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, inputFocusCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get input focus reply", iFree);
		if(reply){
			window = (*reply).focus;
			free(reply);
			popPointer(token);
		}
		ret window;
	}
}
GRABDEVICE(){
	uint currentAttempt = 0;
	struct timespec ts;
	ts.tv_sec = 0;
	ts.tv_nsec = 10 * 1000000;
	if(!attemptAmount){
		ret false;
	}
	jmp grabDeviceLoop;
	grabDeviceLoop:{
		void *reply;
		uint32 token;
		switch(device){
			to KEYBOARD_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC), NULL);
				token = pushPointer(reply, "grab keyboard reply", iFree);
				brk;
			}
			to POINTER_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_pointer_unchecked(connection, true, (*screen).root, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, getTimestamp()), NULL);
				token = pushPointer(reply, "grab pointer reply", iFree);
				brk;
			}
			off:{
				ret true;
			}
		}
		if(reply){
			const bool flag = (*(xcb_grab_keyboard_reply_t *)reply).status == XCB_GRAB_STATUS_SUCCESS;
			free(reply);
			popPointer(token);
			if(flag){
				ret true;
			}
		}
		if(inc currentAttempt < attemptAmount){
			nanosleep(&ts, NULL);
			jmp grabDeviceLoop;
		}
		ret false;
	}
}
UNGRABDEVICE(){
	switch(device){
		to KEYBOARD_GRAB_DEVICE: /*-*/ xcb_ungrab_keyboard(connection, getTimestamp()); /*-*/ ret true;
		to POINTER_GRAB_DEVICE: /*--*/ xcb_ungrab_pointer(connection, getTimestamp()); /*--*/ ret true;
		off: /*---------------------*/ /*--------------------------------------------------*/ ret false;
	}
}
FILLDRAWABLE(){
	xcb_rectangle_t rectangle;
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_change_gc(connection, gc, XCB_GC_FOREGROUND, &color);
	xcb_poly_fill_rectangle(connection, drawable, gc, 1, &rectangle);
	ret;
}
SETCLIPPINGRECTANGLE(){
	xcb_rectangle_t rectangle;
	if(!gc){
		ret false;
	}
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_set_clip_rectangles(connection, XCB_CLIP_ORDERING_UNSORTED, gc, 0, 0, 1, &rectangle);
	ret true;
}
TIGHTENCLIPPINGRECTANGLE(){
	int intersectionX;
	int intersectionY;
	int intersectionWidth;
	int intersectionHeight;
	if(!gc or !clipXReturn or !clipYReturn or !clipWidthReturn or !clipHeightReturn){
		ret false;
	}
	getIntersection(x, y, width, height, *clipXReturn, *clipYReturn, *clipWidthReturn, *clipHeightReturn, &intersectionX, &intersectionY, &intersectionWidth, &intersectionHeight);
	setClippingRectangle(gc, intersectionX, intersectionY, intersectionWidth, intersectionHeight);
	*clipXReturn = intersectionX;
	*clipYReturn = intersectionY;
	*clipWidthReturn = intersectionWidth;
	*clipHeightReturn = intersectionHeight;
	ret true;
}
UNSETCLIPPINGRECTANGLE(){
	struct{
		xcb_pixmap_t /*-*/ clipMask;
	} valueList;
	if(!gc){
		ret false;
	}
	valueList.clipMask = XCB_NONE;
	xcb_change_gc(connection, gc, XCB_GC_CLIP_MASK, &valueList);
	ret true;
}
RESTART(){
	if(!isInsideConfig){
		disconnectSharedMemory(&sharedMemorySystem);
		disconnectSTDIN(&stdinSystem);
	}
	freeConfigVariables();
	ungrabShortcuts();
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	setConfigVariables();
	ret;
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiWindowSystem(&windowSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagerSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagerSystem.data + 1, memoryManagerSystem.data + memoryManagerSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
CANCELTHREADS(){
	if(globalsLockCreated){
		if(pthread_rwlock_destroy(&globalsLock) != PTHREAD_RWLOCK_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy globals lock");
		}
		globalsLockCreated = false;
	}
	ret;
}
PRINTUNACCOUNTEDFORPOINTERS(){
	if(current < wall){
		jmp printPointedVariablesLoop;
		printPointedVariablesLoop:{
			if((*current).data){
				labelExamined = (*current).label;
				printError("\t%s: line %u: %s\n", (*current).file, (*current).line, labelExamined);
			}
			if(inc current < wall){
				jmp printPointedVariablesLoop;
			}
		}
	}
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		va_list arguments;
		va_start(arguments, message);
		flockfile(errorStream);
		vfprintf(errorStream, message, arguments);
		funlockfile(errorStream);
		va_end(arguments);
		closeErrorStream();
	}
	ret;
}
PRINTTITLEDERROR(){
	printError("%s%s: %s%s:%s %s\n", colorStart, programName, colorError, title, colorEnd, message);
	ret;
}
PRINTTITLEDQUOTEDERROR(){
	printError("%s%s: %s%s:%s \"%s\" %s\n", colorStart, programName, colorError, title, colorEnd, argument, message);
	ret;
}
PRINTCONNECTIONERROR(){
	const char *string;
	jmp findConnectionError;
	findConnectionError: switch(xcb_connection_has_error(connection)){
		to XCB_CONN_ERROR: /*-------------------*/ string = "socket/pipe/stream error"; /*------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_EXT_NOTSUPPORTED: /*-*/ string = "extension not supported"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_MEM_INSUFFICIENT: /*-*/ string = "insufficient memory"; /*-----------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_REQ_LEN_EXCEED: /*---*/ string = "exceeded request length"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_PARSE_ERR: /*--------*/ string = "error parsing display string"; /*--*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_INVALID_SCREEN: /*---*/ string = "screen-display mismatch"; /*-------*/ jmp printConnectionError;
		off: /*---------------------------------*/ string = "unrecognized connection error"; /*-*/ jmp printConnectionError;
	}
	printConnectionError:{
		printTitledError("fatal X server error", string);
		ret;
	}
}
PRINTTITLEDNAMEDERROR(){
	printError("%s%s: %s%s:%s %s %s\n", colorStart, programName, colorError, title, colorEnd, message, name);
	ret;
}
PRINTXERROR(){
	#define useExtensionName(n0, n1) /*------*/ n0 == n1##ErrorName? "X " #n1 " error"
	#define useErrorName(n0, n1) /*----------*/ n0 == n1##ErrorName and (*error).error_code >= n1##BaseError? *(n1##ErrorName + ((*error).error_code - n1##BaseError))
	#define useErrorOperationName(n0, n1) /*-*/ n0 == n1##ErrorName? *(n1##OperationName + ((*error).minor_code >= countof(n1##OperationName)? countof(n1##OperationName) - 1 : (*error).minor_code))
	#define baseBaseError (0)
	const xcb_generic_error_t *const error = (void *)event;
	printError("%s%s: %s%s:%s %s error in %s operation using the 0x%x resource\n", colorStart, programName, colorError
		, name == baseErrorName? "X error"
		: useExtensionName(name, randr)
		: "X unrecognized extension event"
		, colorEnd
		, useErrorName(name, base)
		: useErrorName(name, randr)
		: "unrecognized"
		, useErrorOperationName(name, base)
		: useErrorOperationName(name, randr)
		: "unrecognized"
	, (*error).resource_id);
	ret;
	#undef  useErrorOperationName
	#undef  useErrorName
}
PRINTTITLEDVALUEDERROR(){
	printError("%s%s: %s%s:%s %s %u\n", colorStart, programName, colorError, title, colorEnd, message, value);
	ret;
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch(*(inc instructionStart)){
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	}
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}
OPENERRORSTREAM(){
	if(!mustOpenErrorStream){
		ret true;
	}
	errorStream = fopen(errorPath, "a");
	errorStreamToken = pushPointer(errorStream, "error stream", fclose);
	if(errorStream){
		ret true;
	}
	mustOpenErrorStream = false;
	errorStream = DEFAULT_ERROR_STREAM;
	colorStart = MESSAGE_START;
	colorFatal = MESSAGE_FATAL;
	colorError = MESSAGE_ERROR;
	colorEvent = MESSAGE_EVENT;
	colorEnd = MESSAGE_END;
	printTitledError("stream error", "could not open error file, reverting to the default error stream");
	ret true;
}
CLOSEERRORSTREAM(){
	if(!mustOpenErrorStream or !errorStream){
		ret false;
	}
	fclose(errorStream);
	popPointer(errorStreamToken);
	errorStreamToken = 0;
	ret true;
}

